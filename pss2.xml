<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Fireplace</title>
    <link>http://blog.jeon.sh/</link>
    
    <atom:link href="http://blog.jeon.sh/pss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 19 Nov 2021 00:08:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>유니티 파일시스템에서 메타데이터 숨기기</title>
      <link>http://blog.jeon.sh/post/3/</link>
      <guid>http://blog.jeon.sh/post/3/</guid>
      <pubDate>Mon, 15 Mar 2021 14:00:40 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;배포될 유니티 앱에서 파일시스템에 존재하는 메타데이터를 숨기는 튜토리얼&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;본 작업은 기본적인 &lt;code&gt;il2cpp&lt;/code&gt; 작업 흐름에 대해 이해하신 다음 확인하시는 편이 좋습니다.&lt;br&gt;&lt;strong&gt;Wi</description>
        
      
      
      
      <content:encoded><![CDATA[<p>배포될 유니티 앱에서 파일시스템에 존재하는 메타데이터를 숨기는 튜토리얼</p><blockquote><p>본 작업은 기본적인 <code>il2cpp</code> 작업 흐름에 대해 이해하신 다음 확인하시는 편이 좋습니다.<br><strong>Windows 배포를 위한 체크리스트</strong>에서 이어지는 글입니다.</p></blockquote><p>본 튜토리얼은 <code>2019.4.14f1</code> 버전으로 진행되었습니다. 다른 버전의 유니티인 경우 작업 파이프라인이 상이할 수 있습니다. 윈도우즈 빌드 기준으로 작성되었지만, 안드로이드 플랫폼에서도 동일하게 작업할 수 있습니다. <code>.so</code> 파일에서도 유사한 기법을 사용할 수 있습니다.</p><ul><li><a href="#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0">시작하며</a></li><li><a href="#%EB%8C%80%EC%9D%91">작업하기</a></li><li><a href="#%EC%9D%98%EB%AF%B8%EC%99%80-%EA%B6%81%EA%B8%88%EC%A6%9D">의미와 궁금한 것들</a></li><li><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li></ul><h2 id="시작하며"><a href="#시작하며" class="headerlink" title="시작하며"></a>시작하며</h2><p>유니티는 스크립팅 언어로 <code>C#</code>을 채택하였고, 사용자는 엔진에서 제공하는 <code>API</code>를 이용해 게임 로직을 구현합니다. 네이티브 플러그인이 아닌 경우, 대체로 <code>C#</code> 코드를 사용하며 <code>JIT</code> 컴파일 과정을 거쳐 메모리에 로드되어 동작이 수행됩니다. 에디터에서는 항상 <code>JIT</code> 컴파일 방식으로 동작하며, 빌드 후에는 <code>JIT</code> 컴파일 방식(<code>mono</code>)과 <code>AOT</code> 컴파일 방식(<code>IL2CPP</code>) 중에 선택해 바이너리를 추출할 수 있습니다. </p><p>이 때, <code>AOT</code> 컴파일 방식에서는 <code>Literal String</code>, <code>Method</code>, <code>Struct</code> 정보들을 직접 관리하지 않고 <code>global-metadata.dat</code>라는 파일에 따로 저장하여 보관합니다. <code>GameAssembly.dll</code>이 로드되면서 직접 파일 시스템에 접근하여 메모리에 로드하고 파싱하여 배열로 관리합니다.</p><p>윈도우 빌드한 애플리케이션 기준으로는 <code>[게임이름]_Data\il2cpp_data\Metadata\</code> 경로에 위치합니다.</p><p><img src="https://i.imgur.com/tyaP8d5.png"></p><p><em>모 상용 게임에서 노출되어 있는 글로벌 메타데이터 파일</em></p><p>텍스트 에디터로 열어보시면 바이너리 포맷의 파일임을 확인하실 수 있습니다. 그러나 <code>IL2CPPDumper</code>를 이용하시면 쉽게 데이터를 파싱해 볼 수 있습니다. </p><p><code>Il2CppDumper</code>를 실행하고, <code>GameAssembly.dll</code>과 <code>global-metadata.dat</code>를 차례로 선택해주면, 구조체 데이터가 담긴 헤더, 스크립트 심볼 정보들이 담긴 <code>json</code> 데이터, <code>String Literal</code>이 담긴 <code>json</code>, <code>CPP</code> 코드로 변환되기 전의 구조였을것으로 예상되는 <code>C#</code> 신택스의 클래스 구조, 그리고 이를 묶은 더미 <code>DLL</code>들을 생성해줍니다.</p><p><img src="https://i.imgur.com/aKIhUnO.png"></p><p>이렇게 생성된 파일들에서 <code>dump.cs</code>를 열어보면 <code>C#</code> 문법의 클래스구조가 노출되고 이를 이용해 클래스를 재구성할 수 있습니다. </p><p><img src="https://i.imgur.com/cNwpJkf.png" alt="img"></p><p>위는 <code>global-metadata.dat</code>에서 추출한 클래스구조, 아래는 그를 기반으로 생성한 구조체입니다.</p><p><img src="https://i.imgur.com/pMOUs47.png"></p><p>이렇게 재구성된 클래스로 게임을 공격하는 방법에 대해서는 <a href="/2021/03/05/unity-checklist-for-security-on-windows/#4%EF%B8%8F%E2%83%A3-DLL-%EC%9D%B8%EC%A0%9D%EC%85%98">이 글</a>에서 다루었습니다.</p><h2 id="대응"><a href="#대응" class="headerlink" title="대응"></a>대응</h2><p>누차 말씀드리지만 완벽한 방법은 아니란 것을 항상 기억해주세요. </p><p>저희는 <code>IL2CPP</code> 의 코드를 수정해 이 <code>global-metadata.dat</code> 파일을 숨길 예정입니다. 어떤 작업을 할 지만 읽고도 어떻게 작업할지 감이오시는 분들을 위해 먼저 작업 요약을 작성했습니다.</p><ol><li><code>Project Settings</code> - <code>Player</code> - <code>Other Settings</code> - <code>Configuration</code> - <code>Scripting Backend</code>를 <code>IL2CPP</code>로 선택</li><li><code>File</code> - <code>Build Settings</code> - <code>Create Visual Studio Solution</code> 옵션을 키고 빌드</li><li>생성된 <code>global-metadata.dat</code> 파일을 <code>char array</code>로 변환</li><li>생성된 솔루션의 <code>libil2cpp\vm\MetadataLoader.cpp</code> 수정해서 변환된 <code>char array</code> 하드코딩</li><li><code>Master Configuration</code> 옵션으로 빌드</li></ol><h3 id="1-프로젝트-추출-옵션으로-빌드"><a href="#1-프로젝트-추출-옵션으로-빌드" class="headerlink" title="1. 프로젝트 추출 옵션으로 빌드"></a>1. 프로젝트 추출 옵션으로 빌드</h3><p>빈 프로젝트로 진행하기엔 약간 심심하니 에셋 스토어의 무료 에셋을 하나 다운로드 받아 빌드에 사용합니다. </p><p><img src="https://i.imgur.com/qa2MttD.png"></p><p>Create Visual Studio Solution 옵션으로 빌드하면 아래처럼 파일시스템이 생성됩니다.</p><p><img src="https://i.imgur.com/Kexyz9m.png"></p><p>솔루션에는 4개의 프로젝트가 솔루션 안에 생성됩니다.</p><p><img src="https://i.imgur.com/Yfo1Q63.png"></p><ul><li><code>Il2CppOutputProject</code> : 생성된 코드 프로젝트입니다. 대부분의 작업은 여기에서 진행됩니다.<ul><li><code>IL2CPP</code> : 에디터 버전에 종속되어 설치된 <code>il2cpp</code> 모듈의 일부를 그대로 복사해옵니다.</li><li><code>Source</code> : 작성한 <code>C#</code>코드가 <code>CPP</code> 코드로 생성되어 추가됩니다.</li></ul></li><li><code>UnityPlayerStub</code> : <code>UnityPlayer.dll</code>이 됩니다. 하지만 코드를 수정해도 반영되지 않습니다. 이미 빌드되어있는 <code>DLL</code>파일을 카피해옵니다.</li><li><code>SafeMetadata</code> : <code>프로젝트명.exe</code> 으로 컴파일됩니다. <code>wWinMain</code>에 코드를 작성하면 컴파일되어 반영됩니다. </li></ul><p>간단하게 콘솔을 띄우는 코드로 확인해볼 수 있습니다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, <span class="keyword">int</span> nShowCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AllocConsole();</span><br><span class="line">FILE* file;</span><br><span class="line"></span><br><span class="line">freopen_s(&amp;file, <span class="string">&quot;CONIN$&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen_s(&amp;file, <span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">freopen_s(&amp;file, <span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> UnityMain(hInstance, hPrevInstance, lpCmdLine, nShowCmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기에서 <code>return</code> 하는 <code>UnityMain(...)</code>은 <code>UnityPlayerStub</code>의 <code>Main</code>입니다. 그러니까 프로그램 실행 순서는, <code>exe</code> - <code>UnityPlayer.dll</code> - <code>GameAssembly.dll</code>이 됩니다. 이를 이용해서 어느 타이밍에 어떤 장치를 심을지 결정하시면 됩니다.</p><h3 id="2-메타데이터를-바이너리로-변환"><a href="#2-메타데이터를-바이너리로-변환" class="headerlink" title="2. 메타데이터를 바이너리로 변환"></a>2. 메타데이터를 바이너리로 변환</h3><p>빌드에서 생성되는 <code>global-metadata.dat</code> 파일을 로드해 임의의 <code>byte array</code>로 변환을 거칩니다. 저는 빌드 이벤트에서 진행하는 방식을 택했습니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> BIN = <span class="string">&quot;build\\bin\\&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> METADATA = <span class="string">&quot;il2cpp_data\\Metadata\\global-metadata.dat&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> HEADER = <span class="string">&quot;Il2CppOutputProject\\IL2CPP\\libil2cpp\\vm\\SafeMetadata.h&quot;</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">PostProcessBuild(Order.IL2CPP)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnPostProcessBuild</span>(<span class="params">BuildTarget target, <span class="built_in">string</span> pathToBuildProject</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> BuildTarget.StandaloneWindows:</span><br><span class="line"><span class="keyword">case</span> BuildTarget.StandaloneWindows64:</span><br><span class="line">OnWindows(pathToBuildProject);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="literal">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnWindows</span>(<span class="params"><span class="built_in">string</span> pathToBuildProject</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!UnityEditor.WindowsStandalone.UserBuildSettings.createSolution)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">pathToBuildProject = pathToBuildProject.Replace(<span class="string">$&quot;/<span class="subst">&#123;PlayerSettings.productName&#125;</span>.exe&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> metadataPath = <span class="string">$&quot;<span class="subst">&#123;pathToBuildProject&#125;</span>\\<span class="subst">&#123;BIN&#125;</span><span class="subst">&#123;PlayerSettings.productName&#125;</span>_Data\\<span class="subst">&#123;METADATA&#125;</span>&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> outputHeaderPath = <span class="string">$&quot;<span class="subst">&#123;pathToBuildProject&#125;</span>\\<span class="subst">&#123;HEADER&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">MetadataHeader header = <span class="keyword">new</span> MetadataHeader(metadataPath);</span><br><span class="line">File.WriteAllText(outputHeaderPath, header.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간략하게 빌드 직후에 호출되는 콜백을 이용했습니다. <code>metadata.dat</code> 파일이 있을 것으로 예상되는 경로에서 직접 로드해, <code>header</code> 파일을 생성해줍니다. 전체 소스는 <a href="https://gist.github.com/seonghwan-dev/22a6d1078d902445c6216fcb37d0ffa0">여기</a>에서 보실 수 있습니다. 생성된 메타데이터 파일은 아래와 같습니다.</p><p><img src="https://i.imgur.com/406f47t.png"></p><p><code>global-metadata.dat</code> 파일은 2.25MB 였던 반면 이 헤더 파일은 13MB정도로 커졌습니다. 이 헤더를 <code>IL2CPP</code> 에서 제공하는 메타데이터 로드 부분 코드에서 직접 인클루드하고, 로드할 것입니다.</p><h3 id="3-로드-부분-코드-수정"><a href="#3-로드-부분-코드-수정" class="headerlink" title="3. 로드 부분 코드 수정"></a>3. 로드 부분 코드 수정</h3><p>생성된 솔루션을 열고, <code>Il2CppOutputProject\IL2CPP\libil2cpp\vm</code> 경로에서 <code>MetadataLoader.cpp</code> 소스 파일을 열어주세요. 메타데이터를 로드하는 부분의 코드를 확인할 수 있습니다.</p><p><img src="https://i.imgur.com/xzBEZQ3.png"></p><p>간략히 코드를 설명드리면, 매개변수로 파일이름을 받았고 <code>Metadata</code> 폴더와 함께 경로를 <code>Resolve</code> 한 뒤, 파일 버퍼에 올리고 리턴해줍니다. 파일시스템에서 주어진 파일 이름으로 데이터를 로드하는 간단한 구현입니다.</p><p>이 부분을 아래처럼 수정해줍니다.</p><p><img src="https://i.imgur.com/OgX7L4h.png"></p><p>우선, 앞서 생성했던 <code>SafeMetadata.h</code>를 인클루드 해 줍니다. 2에서 진행한 빌드 이벤트가 제대로 수행되었다면 <code>vm</code> 폴더 경로에 해당 헤더가 존재하고 있을 것입니다. 코드에 그대로 데이터가 정의되어있으므로, 메모리에 데이터를 카피해주고 원래 로직이 하던 것 처럼 리턴해줍니다. 테스트를 빌드해주세요.</p><blockquote><p>빌드 테스트 방법</p><p>bin\Architecture\Build Config\ 경로에 exe 파일이 생성되었을 것입니다.</p><p>실행하기 전에, bin...Data\il2cpp_data\Metadata\global-metadata.dat 파일의 이름을 다른 것으로 바꿔주세요. 이 데이터가 없어도 제대로 게임이 동작하는지 확인해야하기 때문입니다.</p></blockquote><p>테스트에 성공했다면, 배포될 파일 구조에서는 메타데이터를 제외해도 됩니다. 번거롭게 숨겨놓고 메타데이터를 그대로 배포해버리면 전혀 의미 없는 일이 되니 주의해주세요. 2에서 생성했던 빌드 스크립트에서 자동으로 다른 위치로 옮겨두는 로직을 추가하는 것을 권장합니다.</p><h3 id="4-배리에이션"><a href="#4-배리에이션" class="headerlink" title="4. 배리에이션"></a>4. 배리에이션</h3><p>위 스텝들을 통해 메타데이터를 파일시스템 상에 남기지 않을 수 있는 방법을 터득했습니다. 조금 심리적인 방법을 시도해겠습니다. <code>MetadataLoader::LoadMetadataFile</code> 메서드가 호출되는 곳은 <code>MetadataCache::Initialize</code> 함수입니다. 정직하게 리터럴 스트링을 이용해 로드하고 있으며, 이는 여러 정적 분석 도구에서 쉽게 확인이 가능합니다. <a href="/2021/03/05/unity-checklist-for-security-on-windows/#4%EF%B8%8F%E2%83%A3-il2cpp-%EB%B9%8C%EB%93%9C">참고</a> </p><p><img src="https://i.imgur.com/bLgPjAV.png"></p><p>우리는 이미 메타데이터를 <code>DLL</code>에 박아 넣어버렸기 때문에 파일 이름을 매개변수로 전달할 필요가 없습니다. 헤더를 수정해 파라미터를 아예 받지 않도록 바꾸거나, 쓸데없는 파일 이름을 넘겨주며 공격자를 짜증나게 할 수 있습니다. 이것은 작업하시는 분의 선택입니다. 스트링을 남겨두면 메타데이터를 로드하는 곳의 위치를 쉽게 파악할 수 있어 취약점이 될 수도 있지만, <code>GameAssembly.dll</code>의 <code>EntryPoint</code>부터 메타데이터 로드하는 곳 까지는 그렇게 복잡하지 않습니다. 초기화 흐름대로 함수를 따라가다보면 금방 발견하기 때문에 큰 의미를 가지지는 못합니다.</p><p>한 가지 배리에이션의 예시로 제가 작업했던 프로젝트를 소개하겠습니다.</p><p><code>xor</code> 암복호화를 이용해, 한 번 더 꼬아 작업했습니다. 보안상의 이유로 코드는 따로 작성하지 않겠습니다. <code>global-metadata.dat</code>를 매개변수로 받는 부분을 수정하지 않고 그대로 받았습니다. 그리고 파일을 열고, 메모리에 로드했다가 언로드하는 부분의 코드도 주석처리 하지 않았고, <code>xor</code> 연산의 키로, <code>global-metadata.dat</code>라는 스트링을 사용했습니다. </p><p>정적 분석 도구에서 보면 매개변수로 받고도 사용하지 않았다는 점은 쉽게 파악이 가능합니다. 이와 같은 흐름을 파악하게 되면 공격자는 무언가 다른 로드 방식이 숨겨져있을 거라고 생각할 것입니다. 이를 이용해 정상적인 메타데이터 로드를 하는 것처럼 파라미터를 사용하면서도, 실제로 앱과 함께 배포되는 메타데이터 파일은 완전히 더미 데이터입니다. 디버거를 붙인다고 해도, IO도 발생했고 포인터로 액세스하며 메모리에 올라갔다 내려가는 걸 확인할 수 있기 때문에 신경써서 살펴보지 않으면 껍데기일 뿐이라는 것을 눈치채지 못하고 넘어가는 경우가 많습니다. 마지막으로는 상용 패킹 도구를 이용, DLL을 한 번 더 패킹해주면서 어리숙한 정적 분석으로부터 보호받습니다. </p><h3 id="5-자동화"><a href="#5-자동화" class="headerlink" title="5. 자동화"></a>5. 자동화</h3><h4 id="방법-1-il2cpp-빌드-모듈을-수정"><a href="#방법-1-il2cpp-빌드-모듈을-수정" class="headerlink" title="방법 1 - il2cpp 빌드 모듈을 수정"></a>방법 1 - il2cpp 빌드 모듈을 수정</h4><p>사용중인 에디터 버전의 설치경로에는 <code>il2cpp</code>라는 이름의 폴더에 빌드 모듈이 그대로 위치해있습니다. 여기 있는 코드를 미리 수정해두어 빌드 때 마다 여기에서 헤더와 소스 파일을 카피해도록 하는 것입니다. 해당 버전을 사용하는 모든 프로젝트가 수정된 빌드 모듈을 공유해야한다는 단점(장점일 수도 있지요)이 있습니다. 빌드슬레이브에서는 사용해 볼 만한 선택지입니다.</p><h4 id="방법-2-스크립트로-오버라이드"><a href="#방법-2-스크립트로-오버라이드" class="headerlink" title="방법 2 - 스크립트로 오버라이드"></a>방법 2 - 스크립트로 오버라이드</h4><p>권장하는 선택지입니다. 포스트 빌드 콜백에 정의했던 메타데이터 컨버터 스크립트처럼, 빌드 이벤트를 받아 오버라이드하는 방식입니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyCustomScripts_Windows</span>(<span class="params"><span class="built_in">string</span> pathToBuiltProject</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> loaderHeaderPath =</span><br><span class="line">pathToBuiltProject + <span class="string">&quot;\\Il2CppOutputProject\\IL2CPP\\libil2cpp\\vm\\MetadataLoader.h&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> loaderSourcePath =</span><br><span class="line">pathToBuiltProject + <span class="string">&quot;\\Il2CppOutputProject\\IL2CPP\\libil2cpp\\vm\\MetadataLoader.cpp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> customizedHeaderPath = <span class="string">$&quot;<span class="subst">&#123;Application.dataPath&#125;</span>\\SafeMetadata\\Native\\MetadataLoader.h&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> customizedSourcePath = <span class="string">$&quot;<span class="subst">&#123;Application.dataPath&#125;</span>\\SafeMetadata\\Native\\MetadataLoader.cpp&quot;</span>;</span><br><span class="line"></span><br><span class="line">FileInfo loaderHeader = <span class="keyword">new</span> FileInfo(loaderHeaderPath);</span><br><span class="line"><span class="keyword">if</span> (loaderHeader.Exists)</span><br><span class="line">&#123;</span><br><span class="line">loaderHeader.Delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileInfo customizedHeader = <span class="keyword">new</span> FileInfo(customizedHeaderPath);</span><br><span class="line"><span class="keyword">if</span> (customizedHeader.Exists)</span><br><span class="line">&#123;</span><br><span class="line">customizedHeader.CopyTo(loaderHeaderPath);</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">FileInfo loaderSource = <span class="keyword">new</span> FileInfo(loaderSourcePath);</span><br><span class="line"><span class="keyword">if</span> (loaderHeader.Exists)</span><br><span class="line">&#123;</span><br><span class="line">loaderHeader.Delete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileInfo customizedSource = <span class="keyword">new</span> FileInfo(customizedSourcePath);</span><br><span class="line"><span class="keyword">if</span> (customizedHeader.Exists)</span><br><span class="line">&#123;</span><br><span class="line">customizedHeader.CopyTo(loaderSourcePath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>미리 수정한 헤더와 소스 파일을 프로젝트에 포함시켜두고, 빌드 이벤트로 카피해 덮어쓰기하는 방식입니다. </p><p>여기까지가 메타데이터를 숨기기위해 사용되는 필수적인 수정사안들에 대한 자동화 제안입니다. 이외에 추가로 구현할 수 있는 <code>xor</code> 방식 암호화 등도 함께 붙여 사용하시면 됩니다. 단일 빌드에 대해 진행해야할 작업이 많고 번거로운 만큼 자동화 파이프라인을 갖춰두는 것이 생산성에 큰 도움이 됩니다.</p><h2 id="의미와-궁금증"><a href="#의미와-궁금증" class="headerlink" title="의미와 궁금증"></a>의미와 궁금증</h2><h4 id="Q-앱이-차지하는-데이터-용량이-늘어나나요"><a href="#Q-앱이-차지하는-데이터-용량이-늘어나나요" class="headerlink" title="Q. 앱이 차지하는 데이터 용량이 늘어나나요?"></a>Q. 앱이 차지하는 데이터 용량이 늘어나나요?</h4><p><code>global-metadata.dat</code> 파일의 용량은 2MB 였던 반면 생성한 헤더는 13MB였습니다. 그러나 이 작업을 진행하기 전 후로 나누어 <code>GameAssembly.dll</code>의 용량을 비교하면, 8MB / 10MB로 사실상 데이터가 커진 것은 아닙니다. 컴파일되면서 데이터영역으로 들어가버려 다시 바이너리 형태로 저장되었기 때문입니다. 용량의 이점이나 손해는 미미합니다.</p><h4 id="Q-전부-다-했어요-이제-안-뚫리나요"><a href="#Q-전부-다-했어요-이제-안-뚫리나요" class="headerlink" title="Q. 전부 다 했어요. 이제 안 뚫리나요?"></a>Q. 전부 다 했어요. 이제 안 뚫리나요?</h4><p>치트엔진을 설치하고, 빌드한 앱을 켜보세요. 치트엔진에서 유니티 프로세스를 찾아 어태치 하고, 상단 메뉴에서 Mono Dissect 메뉴를 선택해보세요. 메타데이터에 저장되어있던 심볼들이 그대로 노출됩니다. 들인 노력에 비해 너무 간단하게 무력화됩니다. 이런 방식의 접근은 다르게 차단해야합니다. 치트엔진의 이 기능은 <code>DLL</code>을 강제로 로드한 뒤 데이터에 접근하는 방식인데요, <a href="/2021/03/05/unity-checklist-for-security-on-windows/#3%EF%B8%8F%E2%83%A3-%EB%AA%A8%EB%93%88-%EB%B3%B4%ED%98%B8">이전 포스트</a>에서 <code>DLL Injection</code>을 막는 방법 중의 하나를 소개했습니다. <code>DLL</code> 인젝션을 막거나, 치트엔진의 <a href="https://github.com/cheat-engine/cheat-engine/blob/master/Cheat%20Engine/MonoDataCollector/MonoDataCollector/PipeServer.cpp">데이터 콜렉터 소스</a>를 보고 작동하지 않도록 <code>IL2CPP</code> 모듈을 수정해야합니다. 이 부분에 대해서는 내용 정리 중에 있습니다.</p><h4 id="Q-UnityPlayer-dll도-수정하고-싶어요"><a href="#Q-UnityPlayer-dll도-수정하고-싶어요" class="headerlink" title="Q. UnityPlayer.dll도 수정하고 싶어요"></a>Q. UnityPlayer.dll도 수정하고 싶어요</h4><p>유니티 엔진 코드 라이센스를 하시면 <code>IL2CPP</code> 빌드 솔루션도 함께 주는 것으로 알고 있습니다. 코드 라이센스 없이 할 수 있는 작업 레벨에서만 도움을 드릴 수 있을 것 같습니다. 얘기가 나온 김에, 조금 재미있는 장난을 쳐보겠습니다. </p><p><code>Hex Editor</code>를 사용해 <code>UnityPlayer.dll</code>을 엽니다.</p><p><code>GameAssembly.dll</code> 을 검색합니다.</p><p><img src="https://i.imgur.com/WXv5ry9.png"></p><p>적당한 길이의 스트링으로 바꿔줍니다. 저는 언리얼 엔진으로 바꾸었습니다.</p><p><img src="https://i.imgur.com/AqUcOFr.png"></p><p><code>GameAssembly.dll</code> 파일이름도 <code>UnrealEngine.dll</code>로 바꾸어주었습니다. 실행이 잘 됩니다.</p><p><img src="https://i.imgur.com/1Yi8DVA.png"></p><p>로드된 모듈을 확인하니 <code>UnityPlayer.dll</code>와 <code>UnrealEngine.dll</code>이 공존하고 있습니다. 쉽게 볼 수 없는 진풍경이네요. 이를 잘 이용하면, Op코드를 수정해 <code>GameAssembly.dll</code>을 로드하고 제대로 로드되었는지 확인하는 코드를 스킵해버리도록 변경할 수도 있습니다. 그리고 <code>exe</code> 파일에서 <code>UnityPlayer.dll</code>을 로드하기 전, <code>GameAssembly.dll</code>에 해당하는 데이터를 임의로 메모리에 로드할 수 있게됩니다. 라이엇 게임즈의 레전드 오브 룬테라는 이와 유사한 <code>stub.dll</code> 기법을 이용해 PE영역을 제거해 로드 되기 전에는 정적분석 되기 힘든 DLL을 임의로 로드하고 있습니다. </p><h4 id="Q-병행하면-좋은-다른-기법들이-있나요"><a href="#Q-병행하면-좋은-다른-기법들이-있나요" class="headerlink" title="Q. 병행하면 좋은 다른 기법들이 있나요?"></a>Q. 병행하면 좋은 다른 기법들이 있나요?</h4><p>패킹을 고려해보시는 것도 괜찮습니다. 단점으로는 앱 구동 준비 시간이 길어집니다. 실행하고 몇 초 정도 앱 프레임이 뜨지 않고 로드됩니다. 게임 퍼포먼스상으로는 차이가 없습니다. 클래스명, 함수명, 변수명 난독화는 필수적으로 선행되어야합니다. </p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>치트엔진의 모노데이터콜렉터 기능이 매우 치명적입니다. <code>IL2CPP</code> 방식의 유니티 앱은 여러 모듈을 사용하고 모듈 간 통신이 필수적이기 때문에 허용되지 않은 모듈에서 역시 export된 기능을 쉽게 사용할 수 있습니다. 특히 모노 데이터 콜렉터는 그 점을 확실히 인지하고, 메타데이터 파일과 관계없이 메모리에 로드된 상태의 데이터를 긁어갑니다. 근본적으로 <code>IL2CPP</code> 모듈 부분을 모두 뜯어고치거나, <code>UnityPlayer.dll</code>과 통신하는 방법을 교체 또는 감시하는 방식을 추가해야합니다. 가장 무식하면서도 직관적이라고 생각하는 방법은 <code>Game.exe</code>, <code>GameAssembly.dll</code>, <code>UnityPlayer.dll</code>을 모두 단일 파일로 묶어버리는 것입니다. 코드 라이센스 없이는 힘든 작업이겠죠.</p><p>우리가 편의를 위해 상용엔진을 사용하기로 한 이상, 그로부터 발생하는 모든 부분은 트레이드 오프의 연장선에 있습니다. 라이센스를 하지 않으면 코드를 알 수 없는 블랙박스이기 때문에 해킹이 어렵지 않나 생각할 수도 있지만, 코드 라이센스를 하지 않은 모든 게임들은 동일한 파이프라인 위에서 제작되었다는 점을 고려하면 더 취약하다고 볼 수도 있습니다. 특정 유니티 함수의 바이너리 코드 패턴을 찾아내는 방식으로 제작된 치트라면 다른 게임에서도 동작할 수도 있는 여지가 있죠. 그만큼 ‘범용적’으로 공격받기 쉽다는 얘기입니다.</p><p>상용 안티치트 솔루션을 사용하지 못하는 이상 저희는 ‘유니티 게임’의 스테레오 타입에서 최대한 벗어나야 합니다. ‘모든 유니티 게임’에서 동작하기위해 설계된 프로그램이 작동하지 않는 것만 해도 공격시도의 90% 이상을 막아낼 수 있다고 생각합니다. 만약 상용 안티치트를 쓰더라도, 이를 게을리해서는 안됩니다. 유니티 특성상 안티치트 역시 <code>C#</code> 레이어에서 실행이 되는 경우라거나 쉽게 그 사용처와 로딩 방식이 드러나기도 합니다. 어떤 안티치트를 사용하고 어떻게 로드되는지 알려진다면 그 비싼 로열티 지출이 있으나 마나한 소비가 됩니다. </p><p>게임을 개발하시는 모든 분들이 많은 시간 고생해서 만들어낸 소중한 작업물들을 스스로 보호할 수 있으면 좋겠습니다.</p>]]></content:encoded>
      
      
      <category domain="http://blog.jeon.sh/categories/3/">3</category>
      
      
      <category domain="http://blog.jeon.sh/tags/%EC%9C%A0%EB%8B%88%ED%8B%B0/">유니티</category>
      
      
      <comments>http://blog.jeon.sh/post/3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>유니티 안전한 Windows 배포를 위한 체크리스트</title>
      <link>http://blog.jeon.sh/post/2/</link>
      <guid>http://blog.jeon.sh/post/2/</guid>
      <pubDate>Fri, 05 Mar 2021 07:05:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;목차&quot;&gt;&lt;a href=&quot;#목차&quot; class=&quot;headerlink&quot; title=&quot;목차&quot;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0&quot;&gt;시작하며&lt;/a&gt;&lt;/li&gt;
&lt;l</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0">시작하며</a></li><li><a href="#%EC%9C%84%ED%97%98%EC%9A%94%EC%86%8C">위험요소</a></li><li><a href="#%EB%8C%80%EC%9D%91">대응</a></li><li><a href="#%EB%A7%88%EC%B9%98%EB%A9%B0">마치며</a></li></ul><h2 id="시작하며"><a href="#시작하며" class="headerlink" title="시작하며"></a>시작하며</h2><p>안녕하세요.</p><p>오늘은 윈도우 플랫폼에서의 유니티 프로그램이 최소한의 보안 사항을 갖추기 위해 확인해야할 체크리스트를 소개해 드리고자 합니다. 보안을 향상하기 위한 기법은 모두 나열하기 힘들 정도로 다양합니다. 그 중에서도 기본적인 원칙들을 안내하고, 마지막으로 Shipping 하기 전에 확인해야 할 사안들을 중점적으로 다룹니다. 따라서 최종 빌드를 제출하기 전 이 체크리스트를 숙지한다면 허무하게 프로그램을 도둑맞을 가능성을 줄일 수 있습니다. </p><p>본격적으로 방어 수단을 설명하기전에, 어떤 방식으로 취약점을 공격하는지 큰 덩어리들을 소개하고 싶습니다. 배포전에 확인해야할 체크리스트라는 타이틀이지만 개발 초반이나 한창 때 확인하신다면 더욱 견고한 프로그램을 빌드하실 수 있습니다.</p><p>본 정보는 보안관련 전공자가 작성하지 않아 전문성과 공신력을 겸비한 글이라 보기 어렵습니다. 잘못된 정보 또는 오해의 소지가 있는 표현을 발견하시면 댓글이나 메일로 제보 부탁드립니다.</p><h2 id="위험요소"><a href="#위험요소" class="headerlink" title="위험요소"></a>위험요소</h2><ol><li><a href="#1%EF%B8%8F%E2%83%A3-%EB%A1%9C%EC%BB%AC-%ED%8C%8C%EC%9D%BC-%EB%B3%80%EC%A1%B0">로컬 파일 변조</a></li><li><a href="#2%EF%B8%8F%E2%83%A3-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%B3%B5%EC%9B%90">프로젝트 복원</a></li><li><a href="#3%EF%B8%8F%E2%83%A3-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%80%EC%A1%B0">메모리 변조</a></li><li><a href="#4%EF%B8%8F%E2%83%A3-DLL-%EC%9D%B8%EC%A0%9D%EC%85%98">DLL 인젝션</a></li></ol><h3 id="1️⃣-로컬-파일-변조"><a href="#1️⃣-로컬-파일-변조" class="headerlink" title="1️⃣ 로컬 파일 변조"></a>1️⃣ 로컬 파일 변조</h3><p>낮은 레벨의 해커들이 가장 먼저 시도하는 공격 대상은 사용자의 디스크 드라이브에 존재하는 파일들에 대한 변경입니다. 데이터들은 자체 포맷으로 직렬화되어, binary 방식으로 저장됩니다. <code>Resources</code> 폴더 안에 위치한 에셋들, 유니티로 작업한 <code>Scene</code>,  이 <code>Scene</code>에 포함된 게임오브젝트들과 에셋들이 대표적인 사례입니다. 이미지나 사운드 파일 같은 아트 에셋들이 큰 비중을 차지하지만, 간혹 직렬화 된 게임 정적 데이터가 포함되기도 합니다. </p><p><img src="https://i.imgur.com/I9tD1Ha.png" alt="[그림 1]"></p><h5 id="그림-1-HxD-에디터로-본-globalgamemanagers"><a href="#그림-1-HxD-에디터로-본-globalgamemanagers" class="headerlink" title="[그림 1] HxD 에디터로 본 globalgamemanagers"></a>[그림 1] HxD 에디터로 본 globalgamemanagers</h5><p>뜻을 이해할 수 없는 문자들로 보이지만 어렴풋이 <code>2019.4.14f1</code> 글자를 발견할 수 있습니다. 유니티로 개발을 어느정도 진행하셨다면 유니티 엔진의 버전 컨벤션과 비슷함을 눈치채셨을 것입니다. 이렇게 식별할 수 있을 법하다는 느낌에서 더 나아가 오픈소스로 개발된 도구를 이용하면 읽을 수 있는 형태로 바꿀 수 있습니다. 프로그램에서 정적으로 사용되는 데이터 값을 임의로 변조할 수 있게 됩니다. ‘<strong>사용자의 장치에서 동작하는 코드의 결과는 신뢰하지 말라</strong>‘는 격언이 있습니다. 딱 맞는 상황은 아니지만 어느 정도 고개가 끄덕여지는 사례 중 하나입니다.</p><p>외부에 존재하는 서버로부터 네트워크를 통해 파일의 무결성을 검사하는 등의 방법으로 확인하는 대응을 할 수 있습니다. </p><h3 id="2️⃣-프로젝트-복원"><a href="#2️⃣-프로젝트-복원" class="headerlink" title="2️⃣ 프로젝트 복원"></a>2️⃣ 프로젝트 복원</h3><p>초보 해커가 어떤 파일을 변조해야할 지 모르겠다면 어떤 선택을 할까요? 배포된 프로그램으로부터 원래의 유니티 프로젝트를 복원을 시도할지도 모릅니다. 저는 처음 상용 프로그램을 대상으로 취약점이 있는지 분석할 때 이 과정에서 실마리를 찾곤 했습니다. 프로그램으로부터 특수한 부정 이익을 취하기 위해서는 그 목표와, 동작 방식에 대한 이해가 견고해야하기 때문입니다. 필수적인 과정은 아니지만 유니티 개발을 접한 적이 있는 개발자라면 유니티스러운 워크플로우 디자인에 대한 이해도를 바탕으로 전체적인 구조를 파악하는데 큰 도움을 받을 수 있습니다.</p><p>어떤 에셋을 구매해 사용했는지, 리소스 이름 컨벤션은 어떤 스타일인지 네트워크 통신은 어떻게 하는지, 서버의 주소는 어디인지, 아직 공개되지 않은 콘텐츠가 포함되어 있는지 등등 거의 대부분의 정보를 획득할 수 있습니다. 이 프로젝트 복원 과정 역시 오픈소스로 개발된 도구들에서부터 시작됩니다. </p><hr><p>실제 예시를 보겠습니다. (<a href="https://github.com/mafaca/UtinyRipper">uTinyRipper</a> 이용)</p><p><img src="https://i.imgur.com/vbjDxxl.png" alt="[그림 2]"></p><p>[그림 2] 배포된 프로그램 폴더를 uTinyRipper에 임포트 해 분석한 모습</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Assets</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">AnimationClip</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">AnimatorController</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Avater</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Cubemap</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Material</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Mesh</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">PrefabInstance</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Resources</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Scene</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ScriptableObject</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Scripts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Shader</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Texture2D</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Texture3D</span></span><br><span class="line"><span class="string">ProjectSettings</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">AudioManager.asset</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">EditorBuildSettings.asset</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>현재 스팀에서 앞서해보기를 진행중인 유니티 게임을 추출한 파일 구조입니다. <code>Resources</code> 폴더 안에 위치하던 에셋들은 <code>Resources.Load&lt;Sprite&gt;(&quot;Sprite/UI/Close&quot;);</code>처럼 <code>string</code> 경로로 호출되기에 그 경로가 유지됩니다. 그 외에 <code>scene</code>에 포함되었거나, <code>Resources</code> 폴더에 포함된 프리팹, 머티리얼, 스크립터블 오브젝트 등등 에셋이 레퍼런스를 갖고 있는 모든 에셋들은 그 타입별로 폴더에 나뉘어 저장됩니다.</p><p>이들 중 가장 중요하다고 볼 수 있는 <code>script</code> 들도 <code>Scripts</code> 폴더에 <code>DLL</code> 별로 나뉘어 저장됩니다. 예시로 복원한 프로젝트에서는 <code>Assembly-CSharp</code>, <code>Unity.TextMeshPro</code>, <code>DOTween</code> 같은 폴더들을 확인할 수 있었습니다. 그러나 IL 코드들을 모두 디컴파일 해 주지는 않고, <code>public</code>, <code>[Serialized]</code> 필드만 선언해주어 컴포넌트가 잡고있던 다른 에셋의 레퍼런스 정보를 잃지 않도록 복원해주는 수준이었습니다. </p><p>예시 프로젝트는 <code>il2cpp</code>를 사용하지 않고 <code>mono</code> 방식으로 배포를 하고 있어 닷넷디컴파일 도구인 <a href="https://github.com/dnSpy/dnSpy">dnSpy</a>와 <a href="https://www.jetbrains.com/ko-kr/decompiler/">dotPeek</a>을 이용해서 <code>C#</code> 코드로 복원했습니다. 디컴파일된 코드 내용들을 유니티 에디터에 넣어주니 스팀을 통해 배포된 클라이언트와 똑같은 방식으로 유니티 에디터에서 플레이가 가능해졌습니다. </p><p>이제 저는 이 프로그램을 실행하며, 로컬에서만 판정되는 데이터들을 인스펙터를 통해 마음대로 조정이 가능하고 심지어 <code>C#</code> 코드를 수정해 원하는 대로 동작을 수정할 수 있습니다. 마음만 먹는다면 서버 주소를 바꾸고, 다른 결제 모듈을 붙여 빌드해 스팀을 통해 플레이하지 않아도 동작하는 속칭 <strong>크랙 버전</strong> 빌드를 생성할 수도 있게 됩니다. 더 나아가 클라이언트 코드를 통해 서버 동작을 유추해, 프리 서버를 만들 수도 있습니다.</p><p>이 정도 수준까지 코드가 복원되는 것은 <code>mono</code>로 빌드 되었을 때만 가능한 이야기입니다. <code>il2cpp</code>로 빌드하면 <code>C#</code> 코드를 복원해 구동하기까지는 굉장히 오랜 시간이 걸립니다. <code>IL</code> 코드를 <code>C#</code> 코드로 바꾸는 것과 <code>CPP</code> 코드를 <code>C#</code> 코드로 바꾸는 것은 하늘과 땅 차이의 노동력을 요구하기 때문입니다. </p><p><a href="#1%EF%B8%8F%E2%83%A3-%EC%BD%94%EB%93%9C-%EB%82%9C%EB%8F%85%ED%99%94">코드 난독화</a>, <a href="#2%EF%B8%8F%E2%83%A3-%EC%97%90%EC%85%8B-%EB%B2%88%EB%93%A4-%EC%95%94%ED%98%B8%ED%99%94">에셋 번들 암호화</a>, <a href="#4%EF%B8%8F%E2%83%A3-il2cpp-%EB%B9%8C%EB%93%9C">il2cpp 빌드</a> 를 통해 어느정도 방지효과를 기대할 수 있습니다.</p><h3 id="3️⃣-메모리-변조"><a href="#3️⃣-메모리-변조" class="headerlink" title="3️⃣ 메모리 변조"></a>3️⃣ 메모리 변조</h3><p>컴퓨터에서 프로그램을 실행하면 파일 시스템에 존재하던 데이터가 메모리에 적재됩니다. 프로그램 내에서 사용하는 재화, 캐릭터의 최대 체력 수치, 마나 수치 등 지정된 위치에 데이터가 저장되고 코드에 의해 값이 읽어들여지고 쓰입니다. 프로그램의 메모리에는 자기 자신만 접근할 수 있는 것은 아닙니다. 다른 프로세스의 메모리에도 임의의 위치에 원하는 값을 쓰거나 읽을 수 있습니다. 이 작업을 일련의 규칙에 따라 수행해주는 프로그램들이 존재합니다.</p><h4 id="치트엔진"><a href="#치트엔진" class="headerlink" title="치트엔진"></a>치트엔진</h4><p><img src="https://i0.wp.com/pentesttools.net/wp-content/uploads/2019/02/cheat-engine-e1551334316320.png?w=613&ssl=1" alt="[그림 3]"></p><p>치트엔진에 대해 한 번 쯤은 들어보셨을거라 생각합니다. 옛 플래시 게임을 즐기셨다면 ‘치트오매틱’ 같은 툴이나 ‘트레이너’들을 사용해본 추억이 있으실지도 모릅니다. 위 도구들은 모두 프로세스에 접근해 메모리상의 값을 임의로 쓰거나, 데이터를 읽어주는 역할을 합니다. 직관적이고 간단한 동작이지만 매우 강력하여 아직까지도 치트엔진을 원천차단하는것은 쉬운 일이 아닙니다. 가장 원초적이면서 효과적인 공격 수단입니다.</p><p>프로그램에서의 값은 계속해서 변화합니다. 예를 들어, 몇 차례의 단계를 거치면 재화의 수치를 조작할 수 있습니다. 치트엔진을 통해 현재 프로그램에서 표기되는 재화 수치를 검색합니다. 재화가 100이면 100을 검색하고, 프로그램에서 재화를 사용합니다. 10을 사용하여 90이 되었습니다. 90을 검색합니다. 이와 같은 방식으로 타겟 값을 변화시켜가며 하나의 주소가 남을 때 까지 반복합니다. 치트엔진에서 제공하는 값 쓰기 기능으로 9,999,999를 입력합니다. 다시 10만큼의 재화를 사용하면, 재화의 값이 9,999,989로 표시됩니다.</p><p>다른 예시로, 캐릭터의 체력을 고정하기도 합니다. 재화를 변경할 때와 마찬가지로 비슷하게 체력 메모리의 위치를 찾습니다. 그리고 체력 메모리에 접근하는 메서드를 찾고, 체력 메모리의 값을 읽을 때 고정된 값을 돌려주도록 설정합니다. 캐릭터가 공격을 당해도 체력이 닳지 않게됩니다.</p><p>더 자세한 치트엔진의 사용 방법은 생략하겠습니다.</p><blockquote><p>비교적 최근 사용되고 있는 린 엔진 역시 치트 엔진과 비슷하게 메모리를 읽고 변조할 수 있는 기능을 탑재하고 있습니다.</p></blockquote><h3 id="4️⃣-DLL-인젝션"><a href="#4️⃣-DLL-인젝션" class="headerlink" title="4️⃣ DLL 인젝션"></a>4️⃣ DLL 인젝션</h3><p>프로그램은 실행과정에서 구동에 필요한 라이브러리들을 로드합니다. 사용자 레벨에서 이용하는 프로그램들은 대부분 Ring3 영역에서 실행됩니다. 컴퓨터의 하드웨어와 운영체제, 드라이버와 명령을 주고 받기 위해서는 Windows가 제공하는 dll 들을 이용해 통신하게 됩니다. 자주 사용하는 라이브러리로는 <code>kernel32.dll</code>, <code>ntdll.dll</code> 등이 있습니다. </p><p>마이크로소프트에서 제공하는 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">Process Explorer</a> 도구를 이용하여 직접 빌드한 League of Legends 모작 프로그램을 실행시켜 로드된 모듈들을 살펴보았습니다. 렌더링을 담당하는 d3d11.dll, 유니티 내장 라이브러리 baselib.dll, 게임 로직이 포함된 GameAssembly.dll들이 프로세스 아래에 적재되어 있습니다.</p><p><img src="https://i.imgur.com/6E21H7k.png" alt="[그림 4]"></p><p>[그림 4] Process Explorer로 확인한 모듈 리스트</p><p>DLL 인젝션 공격은 원하는 동작을 수행하기 위해 임의의 코드를 실행하는 DLL을 프로세스에 강제로 주입합니다. 인젝션은 <code>Injection</code>으로, 주사한다는 의미를 갖고 있습니다. 이 방법을 통해 내부 모듈로서 동작하는 과정에서 외부에서 실행되기 민감한 코드에 접근하고, 제어할 수 있습니다.</p><p>DLL 인젝터를 이용해 직접 생성한 라이브러리를 외부에서 임의로 로드시켜보았습니다. </p><p><img src="https://i.imgur.com/KM7Lslv.png" alt="[그림 5]"></p><p>DLL을 타겟 프로세스에 인젝션하는 방식도 다양하게 존재합니다. 허용되지 않는 모듈 로드 감지를 피하기 위한 메모리에 매뉴얼하게 매핑하는 방법, LdrLoadDll을 이용하는 방법 등이 있습니다. 예시에서는 별다른 기법을 적용하지 않고 CreateRemoteThread와 WriteProcessMemory를 이용했기 때문에 Process Explorer에서도 모듈 확인이 가능했습니다.</p><p>DLL 인젝션은 곧 메서드 후킹으로 이어집니다. 단순히 값을 읽고 쓰는 것만을 위해서는 메모리 변조를 하는 선택이 간편합니다. 복잡한 로직이 필요하거나 메서드를 후킹해서 조작해야할 때 주로 DLL 인젝션을 사용합니다. 이러한 이유로 대부분의 상용 치트 프로그램은 DLL 인젝션을 기반으로하고 있습니다. 치트로 골머리를 앓던 배틀그라운드, APEX LEGEND, CSGO, R6X, Fortnite 등도 예외는 아니었습니다.</p><p><a href="https://ko.wikipedia.org/wiki/%ED%9B%84%ED%82%B9">후킹</a>에 대해 필요한 부분만 간추려 설명드리겠습니다. 특정한 함수가 호출 될 때 다른 함수가 호출되도록 해주는 기법입니다. 함수가 실행되는 부분의 메모리에 다른 주소로 점프하는 바이트 코드를 패치하여, 로직의 흐름을 납치하는 것입니다. 예제를 살펴보겠습니다. A 함수를 후킹해 B 함수를 호출하도록 했습니다. B에서는 자기가 할 일을 수행하고, A를 호출해줍니다. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A();</span><br><span class="line">    HOOK_FUNCTION(A, B);</span><br><span class="line">    A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// ABA</span></span><br></pre></td></tr></table></figure><p>후킹하기 전에는 A를 출력했지만 후킹 후에는 BA를 차례로 출력합니다. 이처럼 특정한 함수가 호출되는 것을 감지할 수 있습니다. 다른 동작을 수행시키거나 알림을 받는 용도로 사용합니다.</p><h4 id="DX11-후킹"><a href="#DX11-후킹" class="headerlink" title="DX11 후킹"></a>DX11 후킹</h4><p>Windows 플랫폼에서 실행되는 대부분의 게임은 DirectX 프레임워크를 이용해 제작됩니다. 간혹 다른 그래픽 아키텍쳐를 사용하는 경우도 있으나, 유니티로 제작된 프로그램들은 <code>DX11</code> 또는 <code>DX12</code>를 사용합니다. 프로그램의 로직이 완료되고, 변경 사항에 따라 렌더링 해야 할 데이터들을 <code>present</code> 단계에서 그리게됩니다. 이 <code>present</code> 단계를 후킹해 게임 렌더링 이후 원하는 그림을 더 그리게 해 줍니다. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 타입 지정, 전방 선언</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span> <span class="params">(__fastcall* IDXGISwapChainPresent)</span></span></span><br><span class="line"><span class="function">    <span class="params">(IDXGISwapChain* pSwapChain, UINT syncInterval, UINT flags)</span></span>;</span><br><span class="line">IDXGISwapChainPresent fnIDXGISwapChainPresent;</span><br><span class="line"><span class="function">HRESULT <span class="title">onPresent</span><span class="params">(IDXGISwapChain* _chain, UINT syncInterval, UINT flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DllMain에서 호출합니다.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">// vTable 가져오는 과정 생략</span></span><br><span class="line">  fnIDXGISwapChainPresent = (IDXGISwapChainPresent)(DWORD_PTR)pSwapChainVTable[SC_PRESENT];</span><br><span class="line">    HOOK_FUNCTION(fnIDXGISwapChainPresent, onPresent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매 프레임 렌더링 될 때 임의의 GUI와 ESP를 그립니다.</span></span><br><span class="line"><span class="function">HRESULT <span class="title">onPresent</span><span class="params">(IDXGISwapChain* _chain, UINT syncInterval, UINT flags)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    MENU::Draw();</span><br><span class="line">    GAME::Draw();</span><br><span class="line">    ESP::Draw();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fnIDXGISwapChainPresent(_chain, syncInterval, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>콘셉은 다르지 않습니다. 결과물을 예시로 살펴보는 것이 이해에 도움이 됩니다.</p><p><img src="https://i.imgur.com/eHlY67U.png" alt="[그림 6]"></p><p>[그림 6] 리그 오브 레전드에서 DLL 인젝션, DX9 후킹과 평타로 제압할 수 있는 미니언 표기 기능 구현</p><h4 id="로직-구현"><a href="#로직-구현" class="headerlink" title="로직 구현"></a>로직 구현</h4><p>리버싱을 통해 클래스, 구조체의 각 필드 위치를 확인합니다. 정보를 토대로 메모리 적재 위치를 정렬해 필드를 선언합니다. 클래스의 인스턴스가 메모리 어디에 있는지 알면 형변환으로 인스턴스 데이터를 가져올 수 있습니다. 적 챔피언의 위치와 내 스킬의 사거리를 파악해 자동으로 스킬을 사용해주는 로직을 작성했습니다. </p><p><em>(이해를 돕기 위해 작성된 코드로, 일부 누락된 선언도 있습니다.)</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hero</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">0x48</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> championName;</span><br><span class="line">    <span class="keyword">char</span> pad_1[<span class="number">0x8</span>];</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">char</span> pad_3[<span class="number">0x142</span>];</span><br><span class="line">    <span class="keyword">float</span> baseAttackDamage;</span><br><span class="line">    <span class="keyword">char</span> pad_4[<span class="number">0x2C</span>];</span><br><span class="line">    <span class="keyword">float</span> additionalAttackDamage;</span><br><span class="line">    <span class="keyword">char</span> pad_2[<span class="number">0x24</span>];</span><br><span class="line">    <span class="keyword">float</span> attackRange;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CastSpell</span><span class="params">(<span class="keyword">int</span> skillIndex, Vector3f position, Obj_AI* target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__fastcall* fnCastspell)</span></span></span><br><span class="line"><span class="function">            <span class="params">(Hero* owner, <span class="keyword">int</span> skillIndex, Vector3f pos, Obj_AI* tar)</span></span>;</span><br><span class="line">        ((fnCastSpell)(GetModuleHandle(<span class="number">0</span>) + (DWORD)oCastSpell))(<span class="keyword">this</span>, skillIndex, position, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Minion</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">0x24</span>];</span><br><span class="line">    <span class="keyword">float</span> health;</span><br><span class="line">    <span class="keyword">char</span> pad_1[<span class="number">0x18</span>];</span><br><span class="line">    <span class="keyword">float</span> maxHealth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oLocalPlayer 0x38D214;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oCastSpell 0x281C82;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Hero* <span class="title">GetLocalPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(Hero**)(GetModuleHandle(<span class="number">0</span>) + (DWORD)oLocalPlayer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">onPresent</span><span class="params">(IDXGI...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> local = GetLocalPlayer();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// minion last hit highlight</span></span><br><span class="line">    <span class="keyword">auto</span> objects = object_manager::GetMinions(Team::Enemy);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> minion : minions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minion-&gt;position.DistanceTo(local-&gt;position) &lt; local-&gt;attackRange * <span class="number">1.5f</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> dmg = local-&gt;baseAttackDamage + local-&gt;additionalAttackDamage;</span><br><span class="line">            <span class="keyword">if</span> (minion-&gt;health &lt; dmg)</span><br><span class="line">            &#123;</span><br><span class="line">              ImGui::LocalWorldCircle(&amp;minion-&gt;position, minion-&gt;bound, Color::Green);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// shoot skill</span></span><br><span class="line">    <span class="keyword">auto</span> enemies = object_manager::GetChamps(Team::Enemy);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> enemy : enemies) &#123;</span><br><span class="line">        <span class="keyword">auto</span> skrg = local-&gt;spellbook-&gt;GetSkill(<span class="number">0</span>)-&gt;GetRange();</span><br><span class="line">        <span class="keyword">if</span> (enemy-&gt;position.DistanceTo(local-&gt;position) &lt; skrg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (local-&gt;spellbook-&gt;CanCastSpell(<span class="number">0</span>)) &#123;</span><br><span class="line">                local-&gt;CastSpell(<span class="number">0</span>, enemy-&gt;position, enemy);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fnIDXGI...(IDXGI...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onPresent</code>는 앞서 DX에서 후킹해 매 프레임 렌더링 될 때 호출되는 함수입니다. 유니티에서의 Update 문과 유사한 라이프사이클을 가진다고 생각해주세요. </p><p>매 프레임 미리 찾아둔 메모리 주소로부터 내 플레이어(LocalPlayer)의 인스턴스를 가져옵니다. <code>object_manager</code>에서 미니언 벡터를 받아옵니다. 내 플레이어가 기본공격을 가해 제압할 수 있다면, 초록색 원을 그립니다. </p><p>모든 적 히어로들을 루프하며, 스킬 사거리 내 적이 있고 스킬이 사용가능한 상태라면 스킬을 적 히어로 위치에 사용합니다. 더 많은 클래스를 분석하면 상대 캐릭터 무브먼트 에이전트의 도착지점까지 알 수 있게 됩니다. 따라서 보다 정교한 예측 스킬을 사용하는 소위 <strong>헬퍼</strong>를 만들어 낼 수 있게 됩니다.</p><p>단순히 메모리 조작을 통해 값을 변경하는 식의 이익을 얻지 않으니 시스템적으로 필터링하기도 까다롭습니다. 정교하게 만들어진 툴은 여느 인간 못지않은 자연스러움을 뽐내면서도 독보적인 실력을 보여주기도 합니다. 체력이 무한이거나 공격력이 무한대거나 구매하지 않은 아이템을 쓰는 등의 일들은 어느정도 예상 가능합니다. 하지만 이런 방식의 이미 클라이언트에서 제공하고 있는 함수들의 흐름을 바꾸어 의도하지 않은 동작을 발생시키는 헬퍼류는 대응하기가 까다롭습니다.</p><p>리그 오브 레전드에서는 몇몇 메서드에 함정을 설치하고, ret check 등 기법들을 다수 사용하여 방지하고 있습니다. 더 나아가 게임 디자인적으로 헬퍼가 독보적인 성능을 발휘하기 어렵도록 밸런스를 정착시켰습니다.</p><hr><p>목적이 GameBreaking이 아니므로 이 쯤에서 DLL 인젝션 소개를 마치도록 하겠습니다. </p><h2 id="대응"><a href="#대응" class="headerlink" title="대응"></a>대응</h2><p>대응 방안 소개에 앞서 결론부터 말씀드리자면 완벽한 보안 기법은 존재하지 않습니다. 제가 전해드리고 싶은 점은 모든 유니티 프로그램에 적용될 수 있는 범용 도구로부터만이라도 스스로 보호하자는 것입니다. 많은 시간과 노력을 할애하여 결과물을 만들어냈지만, 오픈소스 도구 하나로부터 그 모든 노력이 무너진다면 매우 허탈할 수 밖에 없습니다. ‘출시’라는 목표를 향해 쉴 새 없이 달려온만큼, 피땀흘려 제작된 산출물을 보호하기 위한 전략 역시 수립되어야합니다. </p><p>이 글에서 다룰 내용들은 다음과 같습니다.</p><ol><li><a href="#1%EF%B8%8F%E2%83%A3-%EC%BD%94%EB%93%9C-%EB%82%9C%EB%8F%85%ED%99%94">코드 난독화</a></li><li><a href="#2%EF%B8%8F%E2%83%A3-%EC%97%90%EC%85%8B-%EB%B2%88%EB%93%A4-%EC%95%94%ED%98%B8%ED%99%94">에셋 번들 암호화</a></li><li><a href="#3%EF%B8%8F%E2%83%A3-%EB%AA%A8%EB%93%88-%EB%B3%B4%ED%98%B8">모듈 보호</a></li><li><a href="#4%EF%B8%8F%E2%83%A3-il2cpp-%EB%B9%8C%EB%93%9C">il2cpp 빌드</a></li><li><a href="#5%EF%B8%8F%E2%83%A3-%EB%B0%A9%EC%96%B4%ED%98%95-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1">방어형 코드 작성</a></li></ol><h3 id="1️⃣-코드-난독화"><a href="#1️⃣-코드-난독화" class="headerlink" title="1️⃣ 코드 난독화"></a>1️⃣ 코드 난독화</h3><p>난독화(obfuscation)는 소스코드의 텍스트를 뒤죽박죽 섞어 리버스 엔지니어링을 방해하는 작업을 일컫습니다. ‘난독’이라는 단어는 ‘읽기 어렵다’라는 의미입니다. 그렇다면 유니티 프로그램에서 난독화가 어떤 효과를 가져올 수 있을까요?</p><p>코드의 작성에 있어 네이밍 컨벤션은 항상 중요하게 여겨졌습니다. 프로그래밍 언어 별, 사용하는 솔루션 별로 다양합니다. 하물며 언더바를 사용할 지 대소문자로 구분할지 이름까지 붙여져 있습니다. 그만큼 변수와 함수, 클래스 명이 코드의 이해에 끼치는 영향이 어마어마하다는 뜻입니다. 충분히 잘 정해진 메서드의 이름은 코드 로직을 보지 않아도 어느정도 추리할 수 있게 해 줍니다. </p><p>예시 프로젝트로, 난독화 도구를 이용해 아랍어 문자로 변경했습니다. </p><p><img src="https://i.imgur.com/DClmps8.png" alt="[그림 7]"></p><p>원본 소스는 이렇습니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bootstrap</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> test1;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> test2;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        test1 = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        test1++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTick</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(test2);</span><br><span class="line">        test2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">TCorout</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSecondsRealtime</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">            OnTick();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>로직이 간단하기 때문에 어느정도는 파악이 됩니다. 이해를 돕기 위해 단순한 <code>++</code> 계산이나, 코루틴 호출 정도만 사용했습니다. 이 코드는 <code>mono</code>로 빌드되어 <code>IL</code> 코드로 변환되었을 뿐입니다. <code>il2cpp</code> 모듈을 통해 <code>cpp</code>코드로 변환되면 해독의 난이도는 더 상승합니다.</p><p>유니티 에셋스토어에서 가장 인기있는 난독화 도구인 <a href="https://assetstore.unity.com/packages/tools/utilities/obfuscator-48919">obfuscator</a>를 사용했습니다. </p><h4 id="암호화-난독화"><a href="#암호화-난독화" class="headerlink" title="암호화 != 난독화"></a>암호화 <code>!=</code> 난독화</h4><p>난독화 도구의 필요성에 대해 다른 개발자분들과 얘기를 나누던 중, 암호화와 혼동하는 경우가 있음을 알게 되었습니다. <strong>난독화를 진행해도 복호화를 통해 원본 코드를 복구해낼 수 있지 않느냐</strong>는 논지로 의문을 제기해주셨습니다. </p><p>여기서 언급되는 이름 난독화는 VMProtect와 같은 도구에서 제공하는 <code>Mutation</code>이나 <code>Packing</code> 기능을 제공하지는 않습니다. 단순히 네임스페이스, 클래스, 구조체, 변수, 프로퍼티, 함수의 이름을 랜덤으로 변경해줍니다. 이것만으로도 해커들을 충분히 괴롭게 만들 수 있습니다.</p><p>고대의 암호화처럼 알파벳을 5자리씩 시프트해 각 알파벳이 1:1로 대치되도록 변경해주는 과정이 아닙니다. </p><blockquote><p>ex) myclass -&gt; oaenuu (알파벳을 2칸씩 이동시킨 방식)</p></blockquote><h4 id="난독화-도구가-작동하는-과정"><a href="#난독화-도구가-작동하는-과정" class="headerlink" title="난독화 도구가 작동하는 과정"></a>난독화 도구가 작동하는 과정</h4><ol><li>빌드 -&gt; 유니티 링커가 IL 코드를 생성해줍니다.</li><li>난독화 도구가 콜백을 받아 IL 코드를 분석합니다.</li><li>무작위 시드로 중복되지 않는 이름들을 많이 생성합니다.</li><li>새로운 함수나 변수명이 나오면 3에서 생성한 이름을 하나 선택해 모두 바꿉니다.</li><li>난독화 도구가 추후 디버깅을 위한 이름 매핑 테이블을 생성해줍니다.</li></ol><p>따라서 바닐라 코드에서 한 번 난독화 된 이후에는 다시 원래의 이름으로 돌아올 수 없습니다. 개발자만이 갖고 있는 매핑 테이블 데이터를 통해서만 확인이 가능해집니다.</p><h4 id="한계"><a href="#한계" class="headerlink" title="한계"></a>한계</h4><p>정적 분석을 방해하는데는 큰 기여를 합니다. 동적 분석과는 큰 관련이 없습니다. 원활한 동적 분석을 위해서는 정적 분석이 선행되는 것이 편리합니다. 정적 분석을 방해함으로써 얻게되는 부가적인 효과일 뿐, 근본적으로 동적 분석에 영향을 끼친다고 보기는 어렵습니다.</p><p>앞서 소개했던 치트 엔진과 같은 <strong>메모리 변조 도구들에게는 취약</strong>합니다. 어떤 타겟 수치를 변경하기 위해서 변수명이나 클래스명은 크게 중요하지 않기 때문입니다. </p><h3 id="2️⃣-에셋-번들-암호화"><a href="#2️⃣-에셋-번들-암호화" class="headerlink" title="2️⃣ 에셋 번들 암호화"></a>2️⃣ 에셋 번들 암호화</h3><p><code>Resources</code> 폴더 사용을 최소로하고, 수동으로 리소스를 로드하고 관리합니다. 플랫폼의 검수 없이 콘텐츠 변경이 자주 이루어져야하는 모바일 플랫폼에서는 에셋 번들이 적극 사용됩니다. 그에 반해 PC 플랫폼의 경우 비교적 용이하게 <code>Distribution</code> 파이프라인을 구성할 수 있어 리소스 폴더에 모두 때려박고 개발하는 경향이 없지 않아 있습니다. 하지만 변경되지 않은 리소스임에도 불구하고 인덱싱이 변경되면서 아트 리소스 전체를 새로 내려받아야하는 이슈들도 있습니다. 단지 보안이유만이 아닌 성능상이나 개발 프로세스상 권장합니다.</p><p>에셋 번들로 리소스를 관리한다고 해도 언팩의 위험은 충분히 있습니다. 어떻게 암호화가되었든, 결국 메모리에 적재하고 사용하기 위해서는 복호화 과정이 필요합니다. 그 복호화 알고리즘은 사용자의 시스템에 설치된 클라이언트 코드에 존재합니다. 이 코드가 제대로 난독화되어 숨겨지지 않는 이상, 에셋 번들을 암호화하고 관리하는 노고가 무용지물이 될 수도 있습니다.</p><blockquote><p>아니, 어차피 다 뚫릴 건데 귀찮고 복잡하게 삽질할 필요 있나요?</p></blockquote><p>물론, 경험이 많은 해커들에겐 복호화 로직의 위치를 들켜 리소스가 다 드러나기도 할 것입니다. 복호화를 하지 못했더라도, 메모리에 리소스가 올라가는 이상 메모리 덤프 하면 소용 없긴합니다. </p><p>하지만 깃허브에서 쉽게 구할 수 있는 오픈 소스 도구들을 저지하는 것만 해도 충분한 이점입니다. 별로 경험도 없는 해커가 버튼 몇 번 띡띡 눌러서 2년 내내 밤낮으로 개발한 프로그램의 리소스를 줄줄 빼낸다는 건 용납할 수가 없습니다. </p><p>그렇지만… 리버스 엔지니어링에 빠삭한 해커라면? 어쩔 수 없이 방패가 약했던 탓이니까요. </p><p>그렇습니다. </p><p><strong>“졌지만 잘 싸웠다.”</strong><br>이것이 최소한의 목표입니다.</p><h4 id="간편-XOR-암호화"><a href="#간편-XOR-암호화" class="headerlink" title="간편 XOR 암호화"></a>간편 XOR 암호화</h4><p>암호화 방법은 여러가지가 있습니다. OpenSSL을 사용하기도 하고 간편하게 인코딩만 수정하기도 합니다. 예제로는 간편한 xor 알고리즘을 이용해 로드 전 메모리에서 복호화하는 방식을 소개드리겠습니다. 흔히 사용되는 에셋  번들 생성 스크립트, 로드 스크립트에 xor 암호화와 복호화 로직이 추가된 클래스입니다.</p><h5 id="Bundle-Generator"><a href="#Bundle-Generator" class="headerlink" title="Bundle Generator"></a>Bundle Generator</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleGenerator</span></span><br><span class="line">&#123;</span><br><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;AB/build&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateHero</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BuildPipeline.BuildAssetBundles(<span class="string">&quot;Bundles&quot;</span>, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows64);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Global.useEncryption)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">byte</span>[] bytes = File.ReadAllBytes(<span class="string">&quot;Bundles/hero_001_a&quot;</span>);</span><br><span class="line">Cryptographer xor = <span class="keyword">new</span> Cryptographer(<span class="string">&quot;abtest&quot;</span>);</span><br><span class="line">xor.Encrypt(bytes);</span><br><span class="line">File.WriteAllBytes(<span class="string">&quot;Bundles/hero_001_a&quot;</span>, bytes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Encryption-Utility"><a href="#Encryption-Utility" class="headerlink" title="Encryption Utility"></a>Encryption Utility</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cryptographer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">byte</span>[] Keys &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cryptographer</span>(<span class="params"><span class="built_in">string</span> password</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Keys = Encoding.ASCII.GetBytes(password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Encrypt</span>(<span class="params"><span class="built_in">byte</span>[] data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i] = (<span class="built_in">byte</span>) (data[i] ^ Keys[i % Keys.Length]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decrypt</span>(<span class="params"><span class="built_in">byte</span>[] data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i] = (<span class="built_in">byte</span>)(Keys[i % Keys.Length] ^ data[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Loader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">byte</span>[] decrypted = File.ReadAllBytes(<span class="string">&quot;Bundles/hero_001_a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Global.useEncryption)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">new</span> Cryptographer(<span class="string">&quot;abtest&quot;</span>).Decrypt(decrypted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AssetBundle pack = AssetBundle.LoadFromMemory(decrypted);</span><br><span class="line">GameObject marksman = pack.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;marksman_01&quot;</span>);</span><br><span class="line"></span><br><span class="line">GameObject instance = Instantiate(marksman);</span><br><span class="line">instance.transform.position = Vector3.zero;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>비교적 소요 시간이 적게 걸리지만 오픈소스로 쉽게 접할 수 있는 도구들의 언팩 기능으로는 쉽게 열리지 않습니다. 이용자가 적은 소규모의 도구는 여러 게임들의 암호화에 대응하기 위해 키를 지정해주면 xor 복호화를 진행해주기도 합니다. 리소스들이 메모리에 오르내릴 때, 코드를 통해 복호화가 진행되므로 리소스를 보호하기 위해서는 코드의 보호가 선행되어야 함을 명심해주세요.</p><h4 id="미공개-콘텐츠-유출-방지"><a href="#미공개-콘텐츠-유출-방지" class="headerlink" title="미공개 콘텐츠 유출 방지"></a>미공개 콘텐츠 유출 방지</h4><p>에셋 번들로 리소스를 관리하면 얻을 수 있는 이점을 또 있습니다. </p><p>간혹 테스트 빌드에서 사용하던 미공개 콘텐츠가 <code>Resources</code> 폴더에 딸려 함께 배포되는 경우가 생깁니다. 또는 특정한 날에 공개해야 할 콘텐츠를 미리 클라이언트에 포함해 배포하는 경우도 있습니다. 이런 불상사를 개발 파이프라인상으로 막아줄 수 있습니다. 에셋 마다 미니멈 버전을 부여해 타겟 버전에 모자라는 경우 배포되지 않도록 하는 시스템을 만들어두면 편리합니다. 라이엇의 <a href="https://playruneterra.com/ko-kr/">레전드 오브 룬테라</a>의 <a href="https://technology.riotgames.com/news/bringing-features-life-legends-runeterra">테크블로그 포스트</a>에서 아이디어를 얻을 수 있습니다.</p><h3 id="3️⃣-모듈-보호"><a href="#3️⃣-모듈-보호" class="headerlink" title="3️⃣ 모듈 보호"></a>3️⃣ 모듈 보호</h3><p>DLL Injection을 감지해보겠습니다. DLL이 메모리에 로드되는 이벤트를 감지하는 기법은 다양하지만, 관리자 권한이 없는 상태에서 사용가능한 수단으로 한정하면 그 수가 꽤 줄어듭니다. 좀 더 복잡하고 적용이 번거로운 방법들은 각각 독립된 포스트로 튜토리얼이 작성될 예정입니다.</p><p>메모리에 DLL을 매핑하는 수 많은 방법이 존재합니다. 모두를 방어해주는 마법같은 일은 없습니다. 각자 기능을 따로 구현해 적재적소에 사용하여야합니다. 이 글에서는 C# 레이어의 기능과 LDR 2가지 기능을 이용합니다. </p><h4 id="AppDomain-CurrentDomain"><a href="#AppDomain-CurrentDomain" class="headerlink" title="AppDomain.CurrentDomain"></a>AppDomain.CurrentDomain</h4><p>현재 도메인에 로드된 어셈블리들을 검사하는 방식으로 확인 할 수 있습니다. 닷넷에서 제공하는 기능으로 도메인이 추가로 로드되거나 언로드 될 때 호출 되는 이벤트를 등록하거나 현재 로드된 어셈블리 리스트를 확인할 수 있습니다. </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Detector</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 로드 된 어셈블리 확인</span></span><br><span class="line"><span class="keyword">var</span> assemblies = AppDomain.CurrentDomain.GetAssemblies();</span><br><span class="line"><span class="keyword">foreach</span> (Assembly assembly <span class="keyword">in</span> assemblies)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(assembly.Location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 로드 콜백 등록</span></span><br><span class="line">AppDomain.CurrentDomain.AssemblyLoad += OnLoad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 로드 콜백 해제</span></span><br><span class="line">AppDomain.CurrentDomain.AssemblyLoad -= OnLoad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoad</span>(<span class="params"><span class="built_in">object</span> sender, AssemblyLoadEventArgs args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// on detected</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>새로운 어셈블리가 로드되면 OnLoad 콜백이 실행됩니다. 어셈블리 로드 정보를 검사하여 허용되는 어셈블리인지 판단하는 로직을 추가하시면 됩니다. 매 프레임 검사를 수행하기에는 부담스러운 작업입니다. 랜덤한 주기나 필요시 간헐적으로 검사하거나, 다른 스레드에서 적당한 주기로 검사하고 메인 스레드로 디스패치해 메시지를 넘기는 것을 권장드립니다.</p><p>하지만 이 방식을 크게 신뢰하기는 힘듭니다. 무턱대고 다른 프로세스에 DLL을 주입하는 무지막지한 프로그램들도 있기 때문입니다. 확인할 수 없는 어셈블리가 로드되었다고 항상 감지되었다고 보아서는 안되고, 용의선상에 두고 추가적으로 확인하는 과정이 필요합니다. 해당 어셈블리에 대한 정보를 서버로 리포트하거나, 바이트 코드 패턴을 검사해 해킹에 자주 사용되는 함수가 사용되었는지 확인할 수 있습니다. 하지만 이 주입된 어셈블리 역시 VMProtect 등으로 가상화되어 단순 바이트 패턴 검색으로는 찾기 어렵도록 패킹되어 자체적인 방어 수단을 갖추기도 합니다.</p><h4 id="LdrDllNotification"><a href="#LdrDllNotification" class="headerlink" title="LdrDllNotification"></a>LdrDllNotification</h4><p><a href="https://docs.microsoft.com/en-us/windows/win32/devnotes/ldrregisterdllnotification">마이크로소프트 도큐멘테이션</a>에서 자세한 컨벤션과 사용방법을 확인할 수 있습니다. CPP DLL 프로젝트를 생성하고, LDR Notification 콜백을 받도록 이벤트를 등록합니다. 그리고 유니티와 연결하여 유니티에서 LDR 콜백을 받을 수 있게 링크해줍니다. 정상적으로 콜백 등록이 완료되면 DLL이 로드되거나 언로드 될 때 노티파이를 넘겨줍니다. 문서를 보고 직접 코드를 작성해보겠습니다.</p><h5 id="LDR-h"><a href="#LDR-h" class="headerlink" title="LDR.h"></a>LDR.h</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _NTAPI_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NTAPI</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __success(<span class="keyword">return</span> &gt;= <span class="number">0</span>) LONG NTSTATUS;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NT_STATUS_OK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NT_STATUS_OK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_SUCCESS ((NTSTATUS)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_PROCEDURE_NOT_FOUND ((NTSTATUS)0xC000007A)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_NOT_FOUND ((NTSTATUS)0xC0000225)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_THREAD_IS_TERMINATING ((NTSTATUS)0xc000004b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_NOT_SUPPORTED ((NTSTATUS)0xC00000BB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LDR_DLL_NOTIFICATION_REASON</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LDR_DLL_NOTIFICATION_REASON_LOADED = <span class="number">1</span>,</span><br><span class="line">LDR_DLL_NOTIFICATION_REASON_UNLOADED = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_UNICODE_STRING</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWSTR  Buffer;</span><br><span class="line">&#125; __UNICODE_STRING, * PUNICODE_STRING, * PCUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DLL_LOADED_NOTIFICATION_DATA</span> &#123;</span></span><br><span class="line">ULONG Flags;                    <span class="comment">//Reserved.</span></span><br><span class="line">PCUNICODE_STRING FullDllName;   <span class="comment">//The full path name of the DLL module.</span></span><br><span class="line">PCUNICODE_STRING BaseDllName;   <span class="comment">//The base file name of the DLL module.</span></span><br><span class="line">PVOID DllBase;                  <span class="comment">//A pointer to the base address for the DLL in memory.</span></span><br><span class="line">ULONG SizeOfImage;              <span class="comment">//The size of the DLL image, in bytes.</span></span><br><span class="line">&#125; LDR_DLL_LOADED_NOTIFICATION_DATA, * PLDR_DLL_LOADED_NOTIFICATION_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DLL_UNLOADED_NOTIFICATION_DATA</span> &#123;</span></span><br><span class="line">ULONG Flags;                    <span class="comment">//Reserved.</span></span><br><span class="line">PCUNICODE_STRING FullDllName;   <span class="comment">//The full path name of the DLL module.</span></span><br><span class="line">PCUNICODE_STRING BaseDllName;   <span class="comment">//The base file name of the DLL module.</span></span><br><span class="line">PVOID DllBase;                  <span class="comment">//A pointer to the base address for the DLL in memory.</span></span><br><span class="line">ULONG SizeOfImage;              <span class="comment">//The size of the DLL image, in bytes.</span></span><br><span class="line">&#125; LDR_DLL_UNLOADED_NOTIFICATION_DATA, * PLDR_DLL_UNLOADED_NOTIFICATION_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">LDR_DLL_NOTIFICATION_DATA</span> &#123;</span></span><br><span class="line">LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;</span><br><span class="line">LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;</span><br><span class="line">&#125; LDR_DLL_NOTIFICATION_DATA, * PLDR_DLL_NOTIFICATION_DATA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(CALLBACK* PLDR_DLL_NOTIFICATION_FUNCTION)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_     ULONG                       NotificationReason,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_     PLDR_DLL_NOTIFICATION_DATA NotificationData,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ PVOID                       Context</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* _LdrRegisterDllNotification)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_     ULONG                          Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_     PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ PVOID                          Context,</span></span></span><br><span class="line"><span class="function"><span class="params">_Out_    PVOID* Cookie</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* _LdrUnregisterDllNotification)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ PVOID Cookie</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !_NTAPI_</span></span></span><br></pre></td></tr></table></figure><h5 id="dllmain-cpp"><a href="#dllmain-cpp" class="headerlink" title="dllmain.cpp"></a>dllmain.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LDR.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;user32&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">_LdrRegisterDllNotification LdrRegisterDllNotification = <span class="literal">NULL</span>;</span><br><span class="line">_LdrUnregisterDllNotification LdrUnregisterDllNotifcation = <span class="literal">NULL</span>;</span><br><span class="line">PVOID Cookie = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetNtFunctions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HMODULE hNtDll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> lpModuleName = XorStrW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(hNtDll = GetModuleHandle(lpModuleName)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">LdrRegisterDllNotification = </span><br><span class="line">        (_LdrRegisterDllNotification)GetProcAddress(hNtDll, <span class="string">&quot;LdrRegisterDllNotification&quot;</span>);</span><br><span class="line">LdrUnregisterDllNotifcation = </span><br><span class="line">        (_LdrUnregisterDllNotification)GetProcAddress(hNtDll, <span class="string">&quot;LdrUnregisterDllNotification&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!LdrRegisterDllNotification || !LdrUnregisterDllNotifcation)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>단일 파일이지만 설명을 병행하기 위해 함수별로 쪼개어 작성하였습니다. <code>GetNtFunctions</code> 에서는 <code>ntdll.dll</code>에 정의되어있는 <code>LdrRegisterDllNotification</code> 함수의 주소를 가져옵니다. 이 노티파이 등록 메서드를 직접 호출해 DLL 로드 콜백을 받기 위함입니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">MyDllNotification</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG Reason,</span></span></span><br><span class="line"><span class="function"><span class="params">PLDR_DLL_NOTIFICATION_DATA NotificationData,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Reason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> LDR_DLL_NOTIFICATION_REASON_LOADED:</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;[+] :: &quot;</span> &lt;&lt; NotificationData-&gt;Loaded.BaseDllName-&gt;Buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">auto</span> dllname = NotificationData-&gt;Loaded.BaseDllName;</span><br><span class="line"><span class="keyword">auto</span> targetModule = GetModuleHandle(dllname-&gt;Buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> is_ce_64 = wcscmp(dllname-&gt;Buffer, <span class="string">L&quot;MonoDataCollector64.dll&quot;</span>) == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_ce_64)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> LDR_DLL_NOTIFICATION_REASON_UNLOADED:</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">wcout &lt;&lt; <span class="string">&quot;[-] :: &quot;</span> &lt;&lt; NotificationData-&gt;Loaded.BaseDllName-&gt;Buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyDllNotification</code>은 DLL 로드가 감지되었을 때 호출되는 콜백 함수입니다. 호출 된 이유와 데이터를 파라미터로 밀어넣어줍니다. 모듈 이름이나 경로를 확인할 수 있습니다. 여기에서 받는 모듈 데이터를 직접 처리하거나, C# 레이어로 또 다른 콜백을 호출해 돌려주어 검증하도록 구현할 수 있습니다.</p><p>예시로, 치트엔진에서 제공하는 기능 중 하나인 <code>Mono Dissect</code>를 방지하기 위한 로직을 구현해두었습니다. DLL이 로드되면, 모듈의 이름을 읽고 비교하여 <code>MonoDataCollector64.dll</code>인지 확인합니다. 만약 이름이 확인되었다면 공격 목적의 DLL로 판단하고 원하는 동작을 수행합니다. 간단하게 <code>exit(0)</code>을 호출하여 애플리케이션이 종료되도록 했습니다. </p><blockquote><p>Mono Dissect는 프로세스에 DLL을 주입하여 게임 어셈블리에서 사용하는 클래스와 함수, 변수명들과 <code>Virtual Address</code>를 모두 수집하여 보여주는 기능입니다. 직접 프로세스에 파이프를 꽂는 스타일이라 <code>Mono</code>, <code>il2cpp</code> 할 것 없이 사용가능합니다.</p></blockquote><p><img src="https://i.imgur.com/rcpQ4qr.png" alt="[그림 9]"></p><p>[그림 9] 프로세스가 종료되어버리면서 DllEntryPoint 에서의 작업이 완료되지 못한 채 예외가 발생</p><p>예시에서는 곧바로 프로세스를 닫아버렸지만, 비정상 행동을 감지했을 때 곧바로 종료시켜버리는 것은 좋은 대응 방법이 아닙니다. 공격자는 감지되었음을 인지하고 프로세스를 종료하는 시점을 찾아 중단점을 거는 등의 동적 분석을 통해 보호 루틴의 위치를 찾아내려고 시도할 것입니다. 적당한 텀을 두고 프로세스를 종료하거나, 분석 도구들의 xref 같은 기능이 동작하기 힘든 방식으로 프로세스 종료 루틴을 호출하도록 장치하세요.</p><p>이 콜백을 받았을 때는 DllMain이 호출되기 전이라 해당 스레드 시작부분을 찾아내어 DLL 종료 부분으로 <code>jmp</code>시켜주면 스스로 작업을 끝내고 언로드되는 것 처럼 통과시켜버릴 수도 있습니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Startup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS ret;</span><br><span class="line"><span class="keyword">if</span> (!GetNtFunctions())</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (LdrRegisterDllNotification)</span><br><span class="line">&#123;</span><br><span class="line">ret = LdrRegisterDllNotification(<span class="number">0</span>, &amp;MyDllNotification, <span class="literal">NULL</span>, &amp;Cookie);</span><br><span class="line"><span class="keyword">if</span> (ret != STATUS_SUCCESS)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (LdrUnregisterDllNotifcation)</span><br><span class="line"><span class="keyword">if</span> (Cookie != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">LdrUnregisterDllNotifcation(Cookie);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">bool</span> <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Startup</code>과 <code>Claenup</code>은 위에서 콜백 함수를 LDR 이벤트에 등록해주는 함수입니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                      DWORD ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                      LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> result;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">result = AllocConsole();</span><br><span class="line"></span><br><span class="line">FILE* file;</span><br><span class="line"></span><br><span class="line">freopen_s(&amp;file, <span class="string">&quot;CONIN$&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen_s(&amp;file, <span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">freopen_s(&amp;file, <span class="string">&quot;CONOUT$&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;console created...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">result = Startup();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;startup result :: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH: <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH: <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">&#123;</span><br><span class="line">Cleanup();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DLL Main은 이 DLL이 로드되면 호출됩니다. C# 코드에서 한번 호출 해 주면 스스로 <code>Startup</code> 로직으로 들어가 초기화를 진행합니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">bool</span> <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cleanup();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C# 레이어에서 함수를 호출하기 위해 export합니다. 유니티에서 <code>DllImport</code> 속성을 통해 임포트한 뒤, <code>begin()</code>을 호출하면 DLL이 메모리에 적재되며 동작을 시작하게 됩니다.</p><p>이렇게 윈도우가 기초적으로 제공하는 기능들을 이용해 장치한 함정들은 숙련된 공격자들에 의해 쉽게 파훼될 수 있습니다. 경험 많은 해커의 수는 많지 않지만 여러 치트 커뮤니티를 통해 정보가 공유되곤 합니다. 위 2가지에 안주 할 수 없습니다. 스텔스 인젝션 기능이 있는 인젝터나, 매뉴얼 매핑을 지원하는 인젝터들도 다수 있습니다. 각 방식을 감지하고 확인하기위해 끊임없이 다양한 방법을 시도해야합니다.</p><h3 id="4️⃣-il2cpp-빌드"><a href="#4️⃣-il2cpp-빌드" class="headerlink" title="4️⃣ il2cpp 빌드"></a>4️⃣ il2cpp 빌드</h3><p>안드로이드와 iOS에서 AOT 컴파일만 허용하면서 대응을 위해 il2cpp 빌드가 주류로 자리잡았습니다. PC 플랫폼에서는 따로 배포처에서 강제하는 옵션이 없기때문에 <code>mono</code>로 배포를 해도 반려되거나하는 일은 없습니다. 그러나 PC에서도 성능향상측면에서 il2cpp를 이용해야한다는 정보글도 심심찮게 찾아볼 수 있습니다.</p><p>il2cpp는 유니티 빌드 파이프라인 중 하나로, 이름 그대로 직관적인 작업을 수행합니다. IL to CPP, IL 코드를 CPP 코드로 변환해 컴파일해줍니다. IL 코드는 C# 코드로 다시 복원하기 용이하고, 읽기도 쉬운편입니다. 반면 CPP 코드는 오브젝트로 컴파일되고나면 디스어셈블리 도구를 통해 확인해야하고 사람이 읽고 이해하기에도 난해합니다. 뚜렷한 이유 없이 모노 빌드를 사용하고있다면 il2cpp 빌드로 파이프라인을 변경해보세요.</p><h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><p>모노 빌드 이후 추가로 <code>IL</code> → <code>CPP</code> 과정을 거치기 때문에 빌드 시간은 더 오래 걸립니다. 개발 단계에서 따로 빌드 머신 없이 자주 빌드해야 하는 상황이라면 비효율적일 수 있습니다. 빠른 개발 사이클을 위해 이를 극복하기 위해서는 <code>Jenkins</code>와 같은 도구로, VCS 커밋이 들어오면 해당 해쉬를 버전삼아 자동으로 빌드 수행할 빌드 머신을 세팅하는 것입니다. 여유 시스템 자원이 없다면, 개발 단계에서는 <code>Mono</code>로 <code>Standalone</code> 빌드를 뽑고, 하루에 한 번 정도 <code>il2cpp</code>로 빌드해 <code>Mono</code>와 마찬가지로 동작하는지 확인하는 단계를 넣을 수 있습니다.</p><p>리플렉션의 일부 기능을 사용하지 못할 수도 있습니다. 크게는 <code>System.Reflection.Emit</code> 네임스페이스에 정의된 기능을 사용할 수 없습니다. 나머지 리플렉션 기능에 대해서는 AOT 컴파일러가 타입을 추측할 수 있는 경우에만 사용가능합니다. 리플렉션 기능을 적극 활용하여 코어로직을 작성했다면 단번에 <code>il2cpp</code> 빌드로의 전환이 쉽지 않을 수 있습니다. <a href="https://docs.unity3d.com/Manual/ScriptingRestrictions.html">Unity - Manual: Scripting restrictions (unity3d.com)</a></p><h4 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h4><p>유니티 허브를 통해 설치합니다. il2cpp 빌드를 위한 모듈은 각 에디터 버전에 종속됩니다. 에디터 설치 과정에서 <code>il2cpp</code> 모듈을 추가하셔도 되고, 설치 후 <code>Add Modules</code> 기능을 통해 후에 추가하셔도 무방합니다.</p><p><img src="https://i.imgur.com/03R2crB.png"></p><p>프로젝트 설정의 <code>Player</code> 탭에서 스크립팅 백엔드를 선택할 수 있습니다. <code>il2cpp</code> 모듈이 설치되지 않더라도 <code>il2cpp</code> 선택 아이템을 선택할 수 있으나 빌드를 시도하면 모듈이 설치되지 않았다는 팝업을 띄웁니다. </p><p><img src="https://i.imgur.com/atPRPAE.png"></p><p>빌드를 진행하면, <code>mono</code> 와 유사한 방식으로 빌드를 진행합니다. 리소스를 인덱싱해 묶고, IL 코드를 생성합니다. 여기에서 추가로 IL 코드를 CPP 코드로 바꾸는 과정을 거치며 사용되지 않아 필요없는 코드를 삭제하는 Stripping 단계도 거치게됩니다. 이렇게 <code>GameAssembly.dll</code>은 매번 생성되지만, 다른 <code>exe</code>와 <code>dll</code> 모듈들은 어떻게 생성되는 걸까요?</p><p><img src="https://i.imgur.com/50cCqho.png"></p><p><code>il2cpp</code> 모듈이 설치된 경로를 확인하면, 미리 생성된 <code>&#123;&#123;ProductName&#125;&#125;.exe</code>,  <code>GameAssembly.dll</code>, <code>UnityPlayer.dll</code> 등이 존재합니다. 이 파일들이 <code>output</code> 경로로 복사되면서 빌드 과정이 마무리됩니다.</p><p><img src="https://i.imgur.com/mcEsAhr.png"></p><h4 id="활용"><a href="#활용" class="headerlink" title="활용"></a>활용</h4><p>CPP로 변환된 코드가 GameAssembly.dll로 컴파일 되기 전에 수정할 수 있습니다. 빌드 설정 윈도우에서 <code>Create Visual Studio Solution</code> 옵션을 선택하면 바이너리 파일을 바로 생성해주지 않고 컴파일이 가능한 솔루션을 생성해줍니다. </p><p><img src="https://i.imgur.com/PX4b4qG.png"></p><p>이렇게 생성된 솔루션에서 일부 소스코드를 수정하고 컴파일 할 수 있습니다.</p><p><img src="https://i.imgur.com/ndM9qQ7.png"></p><p>유니티 엔진 코드 라이센스 없이 진행할 수 있는 조치는 대부분 여기에서 이루어집니다. 메서드 정보를 가지고 있는 <code>global-metadata.dat</code> 파일을 숨기거나, 복호화 하거나 실시간으로 다운로드 받아 로컬에 캐시를 남기지 않고 바로 로드하거나, 컴파일 타임에 string을 xor로 숨겨 정적 분석에서 스트링이 드러나지 않도록 하는 등의 방법들이 이 프로젝트 내 코드를 수정하여 수행시킬 수 있습니다. <a href="#3%EF%B8%8F%E2%83%A3-%EB%AA%A8%EB%93%88-%EB%B3%B4%ED%98%B8">모듈 보호</a> 섹션에서 작업해본 LDR을 이용한 구현부 역시 GameAssembly.dll에 직접 박아넣을 수도 있습니다.</p><p>예제로, <code>global-metadata.dat</code> 파일 이름을 변경해 다른 경로에 위치시키고 싶다고 가정해봅시다. </p><p>프로젝트의 <code>libil2cpp\vm\GlobalMetadata.cpp</code> 소스를 확인하면 <code>GlobalMetadata::Initialize</code> 메서드 안에서 <code>global-metadata.dat</code> 를 스트링으로 하드코딩해두고 사용하고 있음을 확인할 수 있습니다.</p><p><img src="https://i.imgur.com/lojDHEY.png"></p><p>이 소스코드에서 파일이름을 변경해봤자, 정적 분석 도구로 해당 메서드 부분을 찾아보면 어떤 경로에서 메타데이터를 로드하는지 쉽게 알 수 있을 것입니다.</p><p>이해를 돕기 위해 이 상태로 빌드한 뒤 확인해보겠습니다. IDA로 열어보면 string 검색을 시작으로 메타데이터를 로드하는 부분을 찾아낼 수 있습니다.</p><p><img src="https://i.imgur.com/8lqmvoA.png"></p><p><img src="https://i.imgur.com/kdLCV9b.png"></p><p><img src="https://i.imgur.com/xffOPOL.png" alt="xref"></p><p><img src="https://i.imgur.com/WaT29Ua.png" alt="disassembled code"></p><p><code>global-metadata.dat</code> 이름을 다른 것으로 변경했더라도, 어떤 메서드에서 사용하는지 알고 있기 때문에 초보자라도 쉽게 찾아내어 메타데이터 파일을 특정할 수 있을 것입니다. <a href="https://gist.github.com/seonghwan-dev/4c6e83f6b5c73b906c560816f6dfdd2b">간단한 xorstring 소스</a>를 추가해 빌드해보겠습니다. </p><p><img src="https://i.imgur.com/AJgCwKW.png"></p><p>비교를 위해 <code>global-metadata.dat</code>은 그대로 유지하고, IDA로 열어보았습니다.</p><p><img src="https://i.imgur.com/vWLDcK0.png"></p><p>함수는 <code>Metadata</code>를 검색해서 찾았습니다. 함수를 찾는 편의를 위해 바꾸지 않았습니다. 해커는 <code>Metadata</code> 역시 xor로 숨기더라도 엔트리포인트로부터 흐름을 따라오며 어렵지 않게 함수를 찾아낼 것입니다. xor 적용 전과 비교하면, string이 그대로 노출되지도 않으며 새로운 <code>do-while</code> 문이 추가된 부분을 확인할 수 있습니다. 간편한 xor 로직으로, 프로젝트에 헤더를 생성해 추가하고 사용하면 됩니다. <code>a1</code> 파라미터는 상위 메서드에서 인자를 넘겨줍니다. </p><p><img src="https://i.imgur.com/huCdaUO.png"></p><p>상기 함수는 <code>sub_1800F42B0</code> 입니다. <code>v81</code> 변수와<code>v82</code>를 사용해 넘겨주고, <code>v1</code>를 리턴받습니다. 결과적으로 <code>v1</code>이 무엇인지 확인하면 경로 또는 로드된 메타데이터 인스턴스를 바로 알 수 있을것입니다. 하지만 위에서 말씀드렸듯이, 리버싱에 경험 많은 해커를 막는 것보다는 눈먼 공격으로부터의 대응이라도 하자는 범위에서의 방어수단입니다.</p><p>위 xor 예시는 ‘꼭 이렇게 하세요’는 아닙니다. 디스어셈블된 코드를 읽고 추측할 수 있는 해커라면 너무나 쉽게 파훼하고 확인가능하기때문입니다. 설사 완벽하게 코드로부터 메타데이터 경로를 숨기거나, 파일을 따로 두지 않고 바이너리에 바로 쑤셔넣어두었더라도 중단점 걸어서 메모리 덤프해버리면 복호화된 메타데이터가 그대로 노출됩니다. 디버거가 붙지 못하도록, 덤프를 방해하도록 또 다른 조치를 병행해서 적용하셔야합니다. </p><blockquote><p>본 섹션은 해킹 원천 봉쇄가 아닌, il2cpp solution 생성 기능을 어떤식으로 활용가능한지에 대한 소개였습니다.</p></blockquote><h3 id="5️⃣-방어형-코드-작성"><a href="#5️⃣-방어형-코드-작성" class="headerlink" title="5️⃣ 방어형 코드 작성"></a>5️⃣ 방어형 코드 작성</h3><p>보편적인 방어 수단이 모두 적용된 상태에서 가장 효과적이면서 중요하다고 볼 수 있는 장치입니다. 난독화, 암호화, il2cpp빌드 이 삼위일체로 분석을 어렵게 만드는데 성공했다면 자연스러운 코드 흐름 속에 개발자만 아는 규칙을 넣어 문제를 감지해내는 방법론입니다. 이런 스타일을 가장 간편하게 접할 수 있는 것은 fakeValue를 사용하는 자료형입니다. 에셋스토어에서 구매할 수 있는 <a href="https://assetstore.unity.com/packages/tools/utilities/anti-cheat-toolkit-152334">AntiCheatToolkit</a>에서도 확인할 수 있습니다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SecuredInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> hiddenValue;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> fakeValue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SecuredInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hiddenValue = Hide(<span class="keyword">value</span>);</span><br><span class="line">fakeValue = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Hide</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span> ^ Secure.key;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsFucked &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> fakeValue != Secure.key ^ hiddenValue; &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Get</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> hiddenValue ^ Secure.key ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span> &#123; hiddenValue = <span class="keyword">value</span> ^ Secure.key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[간소화된 코드] 실제 자료형에서는 implicit, explicit operator를 구현해 편하게 사용할 수 있도록 장치합니다.</p><p>플래그연산으로 값을 바꾸어 저장해둡니다. 실제 밸류는 <code>hiddenValue</code>에 저장되지만, 화면에 표시되는 값은 <code>fakeValue</code>와 동일한 값이 나옵니다. 치트엔진으로 화면에 보이는 값을 찾아 검색해 바꾸게되면, <code>fakeValue</code>만 변경되고 실제 값은 유지됩니다. 이 때 <code>hiddenValue</code>와 비교해 값이 다르면 변조 시도가 있었다고 추측할 수 있게 됩니다. 그러나 이것 역시 쉽게 알 수 있습니다. 치트엔진에서 플래그 연산된 값이나 xor을 거친 값도 추적할 수 있기 때문에, 방법과 숨겨져있다는 점만 안다면 얼마든지 <code>hiddenValue</code>를 조작할 수도 있습니다. 그러지 못하는 해커들을 걸러내는 정도의 수단입니다. 함수를 후킹해 조작하는 경우는 Getter Setter를 바로 사용해버려 감지되지 않게 조작할 수도 있습니다. 큰 효율을 보여주지는 못합니다.</p><p>함수 호출 순서 지정에 따라 후킹 함수의 호출을 감지하는 방법도 있습니다. 이 방법은 충분한 코드 분석 없이 함수를 후킹해 사용하는 해커에게 효과적일 수 있습니다. 최근 즐겼던 게임을 예시로 들어보겠습니다. <em>개발자분이 이 글을 보신다면 ‘아, 우리 게임이구나.’ 하고 아실지도 모르겠네요.</em></p><p>월드를 돌아다니며 캐릭터에게 필요한 아이템을 빠르게 루팅해서 강해지는 목표를 가진 게임입니다. 로직을 확인해보니 간략했습니다. 아이템 박스를 열면 리프레쉬 과정에서 필요한 아이템인지 검사를 하고, 슬롯 UI에서 마크 이미지 컴포넌트의 작동을 시켜주는 방식이었습니다.</p><h5 id="ItemWindow-cs"><a href="#ItemWindow-cs" class="headerlink" title="ItemWindow.cs"></a>ItemWindow.cs</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ItemWindow</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> ItemSlot[] slots;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSlotClick</span>(<span class="params">PointerEventData.InputButton button, ItemSlot slot</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (slots.Contains(slot))</span><br><span class="line">&#123;</span><br><span class="line">PlayerController.instance.TakeItem(slot);</span><br><span class="line">Refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Refresh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// check it need</span></span><br><span class="line"><span class="keyword">var</span> needItems = LocalDB.instance.needItem;</span><br><span class="line"><span class="keyword">foreach</span> (ItemSlot slot <span class="keyword">in</span> slots)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">bool</span> need = needItems.Contains(slot.item.itemCode);</span><br><span class="line">slot.MarkAsNeed(need);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// repaint</span></span><br><span class="line">Repaint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOpen</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Repaint</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ItemSlot-cs"><a href="#ItemSlot-cs" class="headerlink" title="ItemSlot.cs"></a>ItemSlot.cs</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ItemSlot</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> Image isMarked;</span><br><span class="line"><span class="keyword">public</span> Item item;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MarkAsNeed</span>(<span class="params"><span class="built_in">bool</span> enable</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isMarked)</span><br><span class="line">&#123;</span><br><span class="line">isMarked.enabled = enable;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PlayerController-cs"><a href="#PlayerController-cs" class="headerlink" title="PlayerController.cs"></a>PlayerController.cs</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">PlayerController</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PlayerController instance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeItem</span>(<span class="params">ItemSlot itemSlot</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">itemSlot.OnTake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기타 사용된 클래스는 간단한 싱글턴 패턴으로 구현했고 껍데기만 존재해 크게 중요하지 않습니다. 이런 방식의 코드 동작 구조를 파악했고, 많은 코드를 후킹하고 수정할수록 위험성이 커지므로 최소한의 구성으로 자동 루팅 스크립트를 만들기로 결정합니다.</p><p>먼저, Refresh() 함수를 후킹해서, 원본 함수의 호출이 끝난 뒤 ItemSlot의 mark 이미지가 활성화되어있는 슬롯을 캐시하고, OnSlotClick 함수를 호출하기로 합니다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ui_image</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">0x10c</span>]</span><br><span class="line">    <span class="keyword">bool</span> enabled;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item_slot</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">0x18</span>];</span><br><span class="line">    ui_image isMarked;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item_window</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">0x82</span>];</span><br><span class="line">    il2_cpp_list&lt;item_slot*&gt; slots;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__fastcall* t_onslotclick)</span><span class="params">(item_window*, <span class="keyword">int</span>, item_slot*)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> t_onslotclick origin_onslotclick;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__fastcall* t_refresh)</span><span class="params">(item_window*)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> t_refresh origin_refresh;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Refresh</span><span class="params">(item_window* instance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// call origin</span></span><br><span class="line">        origin_refresh(instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// force call onclick cb</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : slots) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;isMarked-&gt;enabled) origin_onslotclick(instance, <span class="number">0</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Refresh 함수만을 후킹했고, onslotclick 함수는 임의로 호출해버렸습니다. 이제 이 스크립트를 적용한 해커는 월드에서 박스를 열기만 해도 자동으로 아이템을 획득하게 될 것입니다. 마우스 클릭을 하지 않더라도요. 이 경우 로직상 설계에 결함이 있다고 보기는 힘듭니다. 게임상 UI 와 코어로직을 분리하지 않아 다소 난잡하게 막 개발한 케이스이긴 하지만 보안상 특출난 잘못을 하고있지는 않습니다. 그러나 후킹 공격이 생길것을 전혀 고려하지 않은 흐름의 코드인 것입니다. </p><p>누군가 이 코드를 후킹할지도 모른다고 가정한 경우 몇 가지 트랩을 생각해 볼 수 있습니다. 예를 들면, <code>OnSlotClick</code> 함수는 마우스 이벤트로부터 시작되어야 할 것입니다. 만약 <code>Refresh</code> 함수가 끝나기 전에 <code>OnSlotClick</code>이 실행된다면 그것은 부정 호출로 간주할 수 있습니다. 모든 Refresh 함수 아래 위로 플래그를 만들어둬 봅시다.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ItemWindow</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnSlotClick</span>(<span class="params">PointerEventData.InputButton button, ItemSlot slot</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag != <span class="number">0x0</span>) &#123;</span><br><span class="line">            <span class="comment">// flag must be 0x0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (slots.Contains(slot))</span><br><span class="line">&#123;</span><br><span class="line">PlayerController.instance.TakeItem(slot);</span><br><span class="line">flag = <span class="number">0x1</span>;</span><br><span class="line">Refresh();</span><br><span class="line">flag = <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOpen</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">flag = <span class="number">0x1</span>;</span><br><span class="line">Refresh();</span><br><span class="line">flag = <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 Refresh 함수를 후킹한 곳에서 OnSlotClick을 호출한다면 flag는 <code>0x1</code> 상태이고, 호출되어서는 안 될 때 호출되었음을 확인할 수 있습니다. 이럴 때는 클라이언트를 종료하지 말고 슬그머니 기록해뒀다가 몰래몰래 백그라운드에서 서버로 쏘는 패킷에 섞어 보내세요. 일정 주기로 모아 밴웨이브를 때리면 됩니다.</p><p><em>Q. <code>Refresh</code>에서 호출하지 않고 따로 <code>Update</code>를 만들어 수동으로 호출할 수도 있지 않나요?</em></p><p>A. 맞습니다. 이 경우는 자기의 치트를 자랑하고 싶은 누군가 공유한 스크립트를 토대로 방어적인 코드로직을 설계한 것입니다. 만약 해커가 어떤 방식으로 후킹하는지 모른다면 좀 더 범용적인 방법으로 트랩을 설치해야겠죠.</p><p>“<strong>슬롯을 클릭하는 콜백함수가 발생하려면 마우스 포인터가 슬롯안에 있어야만 한다</strong>“ 는 점을 활용해보겠습니다.</p><h5 id="ItemSlot-cs-1"><a href="#ItemSlot-cs-1" class="headerlink" title="ItemSlot.cs"></a>ItemSlot.cs</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ItemSlot</span> : <span class="title">MonoBehaviour</span>, <span class="title">IPointerEnterHandler</span>, <span class="title">IPointerExitHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> mouseInteracted;</span><br><span class="line"><span class="keyword">private</span> Image isMarked;</span><br><span class="line"><span class="keyword">public</span> Item item;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mouseInteracted = <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mouseInteracted = <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (mouseInteracted = <span class="number">0x0</span>) &#123;</span><br><span class="line">            <span class="comment">// report!!</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mouseInteracted = <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MarkAsNeed</span>(<span class="params"><span class="built_in">bool</span> enable</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isMarked)</span><br><span class="line">&#123;</span><br><span class="line">isMarked.enabled = enable;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>유니티에서 제공하는 인터페이스인 <code>IPointer...Handler</code>를 이용했습니다. 마우스 커서가 슬롯 안에 들어있었는지 <code>OnTake</code> 콜백에서 확인하는 방식입니다. 이런 방식의 트랩을 회피하기 위해서는 마우스 커서를 슬롯안에 강제로 넣어주는 스크립트 역시 작성되어야합니다. 번거롭죠. 만약 해커가 난독화된 코드를 제대로 파악하지 못해 이런 제약이 있음을 확인하지 못하면 꼼짝없이 함정을 건드리고 마는 것입니다.</p><h5 id="보너스"><a href="#보너스" class="headerlink" title="보너스"></a>보너스</h5><blockquote><p> 위 처럼 자동 루팅 스크립트를 제작했을 때, ‘필요한 아이템’이 다수 존재할 경우, <code>Refresh</code> - <code>OnClick</code> - <code>Refresh</code> - <code>OnClick</code>… 이 중첩되어 한 프레임에 여러번 발생합니다. 분명히 아이템을 획득가능한지 판정은 서버에서 할 테고, 언제 아이템 획득 요청을 보냈는지 로깅이 되고 있겠죠. 레이턴시가 있을 수 있으니, 클라이언트 사이드에서도 한 프레임에 몇 번이나 요청 함수가 호출되었는지 로깅해 서버사이드와 비교해 볼 수 있습니다. 로깅은 실시간으로 하되, 데이터 분석 및 비교는 게임 후에 하는 것이 좋겠죠. 그러나 사용자 환경에 따라 얼마든지 <code>false positive</code>가 발생할 여지가 있으니 확실하게 검증할 필요는 있습니다.</p></blockquote><p>다른 예시로, 스킬을 자동으로 사용해 적을 맞추는 코드처럼 주요한 로직에 여러 함정을 설치할 수 있습니다. 코드로 보여드리지는 않겠지만, 복잡한 코드의 경우 <code>CastSpell</code> 처럼 추상적인 함수 아래 여러 델리게이트가 달려 호출되기도 하고, 순서대로 호출되어야만 하는 코드들이 존재 할 것 입니다.</p><p>MOBA게임에서 플레이어가 적 캐릭터에 마우스 커서를 대고, 스킬을 사용하려고 Q를 눌렀습니다. 스마트키가 켜져있지 않은 경우, 인디케이터를 먼저 그리고 마우스 왼쪽 클릭을 누르면 스킬이 격발될 것입니다. 반면 스크립트는 매 프레임 적의 위치를 계산하다가, 사거리 안에 들어오면 적의 위치에 스킬 사용 함수를 호출할 것입니다.</p><p>이와 같이 실제 플레이어가 정상적인 플레이를 통해 호출될 함수 순서와, 그렇지 않은 경우의 호출 순서를 캡쳐하여 비교하는 식으로 검출할 수도 있습니다.</p><hr><p><strong>본 아이디어는 코드가 충분이 난독화되어 한눈에 게임로직이 파악되기 어렵다는 가정을 전제로 한 기법입니다. 사람의 눈으로 코드를 읽고 어떤 기능을 할지 변수 이름으로부터 추적하기 쉽다면 의미 없는 일입니다.</strong></p><p>실행된 메서드가 정상적인 곳에서부터 시작했는지 체크하는 여러 기법들이 있는데, 이 방법은 기술적인 접근에서 벗어나 논리상으로 그럴듯한 함정을 파는데 집중했습니다. 리턴 어드레스 확인이나 스레드 ID 확인, 콜스택 추적 같은 기능들은 다른 포스트에서 상세하게 다룰 예정입니다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>당초 기획했던 분량을 초과하게되어 함께 담으려 했던 일부 내용들을 분리했습니다. 서비스를 방해하고 부정이득을 취하려는 공격자의 입장에서 생각하고 취약점을 찾기 위해 많은 시간을 보냈습니다. 어디를 공격할지 파악해야 효과적인 방어 전략 수립이 가능하기 때문입니다. 소개한 대부분의 방법들은 ‘탐지’ 방법이지 ‘방지’ 방법은 아닙니다. 부정 사용자 탐지를 할 방법이 있다는 것만으로도 안정적인 서비스 유지에는 큰 도움이 될 것입니다.</p><p>원천적으로 프로세스를 들여다보고 수정하는 일을 금지하기 위해서는 유저모드보다 더 아래 단계에서의 작업들이 필요합니다. 보통 <code>Ring0</code>라고 불리는 커널모드에서 더 많은 권한을 가진채로 동작합니다. 사용자들은 유저모드에 비해 커널 모드에서의 안티치트 프로그램들에 다소 부정적인 여론을 형성하고 있습니다. 주된 이유는 기술적으로 사생활 침해가 가능할 수도 있다고 믿기 때문입니다. 유저모드에서 해 볼 수 있는 작업들을 마친 후, 여유가 된다면 커널 모드에서 작동하는 솔루션도 소개해보도록 하겠습니다.</p><h3 id="앞으로-다룰-내용"><a href="#앞으로-다룰-내용" class="headerlink" title="앞으로 다룰 내용"></a>앞으로 다룰 내용</h3><ul><li>글로벌 메타 데이터 보호</li><li>드라이버 테스트 모드 감지</li><li>VMProtect로 패킹</li><li>RET 체크</li><li>Thread ID 확인</li><li>DX11 VTable 보호</li><li>치트 엔진, 리클래스, 특정 프로세스 감지</li><li>정적 분석 방지 stub 사용</li></ul>]]></content:encoded>
      
      
      <category domain="http://blog.jeon.sh/categories/2/">2</category>
      
      
      <category domain="http://blog.jeon.sh/tags/%EC%9C%A0%EB%8B%88%ED%8B%B0-%EB%B3%B4%EC%95%88/">유니티, 보안</category>
      
      
      <comments>http://blog.jeon.sh/post/2/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
